<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自作CPU性能比較サイト</title>
    <!-- Font Awesome CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* === Keyframe Animations === */
        @keyframes slideDownFadeIn {
            from { opacity: 0; transform: translateY(-25px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideUpFadeIn {
            from { opacity: 0; transform: translateY(25px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes modalSlideIn {
            from { transform: translateY(-60px) scale(0.95); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }
        @keyframes modalSlideOut {
            from { transform: translateY(0) scale(1); opacity: 1; }
            to { transform: translateY(-60px) scale(0.95); opacity: 0; }
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* === スクロールバーを非表示にする共通スタイル === */
        /* Firefox用 */
        .control-group,
        #tagFiltersContainer,
        .settings-tabs,
        #tagSelectionCheckboxes {
            scrollbar-width: none;
        }

        /* Webkit系ブラウザ（Chrome, Safariなど）用 */
        .control-group::-webkit-scrollbar,
        #tagFiltersContainer::-webkit-scrollbar,
        .settings-tabs::-webkit-scrollbar,
        #tagSelectionCheckboxes::-webkit-scrollbar {
            width: 0;
            height: 0;
        }


        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            overflow-x: hidden; 
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .container {
            max-width: 1700px; /* お気に入り列追加のため少し広げる */
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(8px);
            overflow: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        header {
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
            color: white;
            padding: 2rem;
            text-align: center;
            transition: background-color 0.3s ease;
        }
        
        .header-title {
            font-size: 2.8rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            animation: slideDownFadeIn 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94) backwards;
            animation-delay: 0.2s;
        }
        .header-title i {
            margin-right: 10px;
        }
        
        .header-subtitle {
            font-size: 1.2rem;
            opacity: 0; 
            animation: slideDownFadeIn 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; 
            animation-delay: 0.4s;
        }
        
        .controls {
            padding: 1.5rem;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 1.5rem;
            opacity: 0;
            animation: slideUpFadeIn 0.6s ease-out forwards;
            animation-delay: 0.6s;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .control-group { /* For grouping buttons */
            display: grid;
            grid-template-rows: auto auto;
            grid-auto-flow: column;
            gap: 1rem;
            align-items: center;
            overflow-x: auto;
            padding-bottom: 10px;
            margin-bottom: -10px;
            -webkit-overflow-scrolling: touch;
        }

        .add-cpu-btn, .compare-selected-btn, .delete-selected-btn, .settings-btn, .export-btn, .import-btn, #themeToggleBtn, .scatter-plot-btn, .statistics-btn, .info-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease, transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 2px 15px rgba(255, 107, 107, 0.3);
            display: inline-flex;
            align-items: center;
            white-space: nowrap; /* ボタン内のテキストが改行しないように */
        }
        .add-cpu-btn i, .compare-selected-btn i, .delete-selected-btn i, .settings-btn i, .export-btn i, .import-btn i, #themeToggleBtn i, .scatter-plot-btn i, .statistics-btn i, .info-btn i {
            margin-right: 8px;
        }
        
        .add-cpu-btn:hover, .compare-selected-btn:hover:not(:disabled), .delete-selected-btn:hover:not(:disabled), .settings-btn:hover, .export-btn:hover, .import-btn:hover, #themeToggleBtn:hover, .scatter-plot-btn:hover, .statistics-btn:hover, .info-btn:hover {
            transform: translateY(1px) scale(1.03);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.45);
        }
        .add-cpu-btn:active, .compare-selected-btn:active:not(:disabled), .delete-selected-btn:active:not(:disabled), .settings-btn:active, .export-btn:active, .import-btn:active, #themeToggleBtn:active, .scatter-plot-btn:active, .statistics-btn:active, .info-btn:active {
            transform: translateY(-1px) scale(0.98);
            box-shadow: 0 2px 10px rgba(255, 107, 107, 0.25);
        }
        .compare-selected-btn, .delete-selected-btn {
            background: linear-gradient(135deg, #54a0ff, #2e86de);
            box-shadow: 0 4px 15px rgba(84, 160, 255, 0.3);
        }
        .compare-selected-btn:hover:not(:disabled) {
            box-shadow: 0 6px 20px rgba(84, 160, 255, 0.45);
        }
        .compare-selected-btn:disabled, .delete-selected-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: none;
            transform: none;
        }
        .delete-selected-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5253);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        .delete-selected-btn:hover:not(:disabled) {
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.45);
        }
        .info-btn {
            background: linear-gradient(135deg, #3498db, #2980b9); /* Blue */
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
        .info-btn:hover {
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.45);
        }
        .scatter-plot-btn {
            background: linear-gradient(135deg, #26de81, #20bf6b); /* Green */
            box-shadow: 0 4px 15px rgba(38, 222, 129, 0.3);
        }
        .scatter-plot-btn:hover {
            box-shadow: 0 6px 20px rgba(38, 222, 129, 0.45);
        }
        .settings-btn, #themeToggleBtn {
            background: linear-gradient(135deg, #9b59b6, #8e44ad); /* Purple */
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.3);
        }
        .settings-btn:hover, #themeToggleBtn:hover {
            box-shadow: 0 6px 20px rgba(155, 89, 182, 0.45);
        }
        .statistics-btn {
            background: linear-gradient(135deg, #1abc9c, #16a085); /* Teal */
            box-shadow: 0 4px 15px rgba(26, 188, 156, 0.3);
        }
        .statistics-btn:hover {
            box-shadow: 0 6px 20px rgba(26, 188, 156, 0.45);
        }
        #themeToggleBtn {
            padding: 12px 15px; /* Adjust padding for icon-only feel */
        }
        #themeToggleBtn i {
             margin-right: 0;
        }

        .export-btn {
            background: linear-gradient(135deg, #1dd1a1, #10ac84); /* Greenish */
            box-shadow: 0 4px 15px rgba(29, 209, 161, 0.3);
        }
        .export-btn:hover {
            box-shadow: 0 6px 20px rgba(29, 209, 161, 0.45);
        }
        .import-btn {
            background: linear-gradient(135deg, #5f27cd, #341f97); /* Purplish */
            box-shadow: 0 4px 15px rgba(95, 39, 205, 0.3);
        }
        .import-btn:hover {
            box-shadow: 0 6px 20px rgba(95, 39, 205, 0.45);
        }
        
        .search-box-wrapper {
            position: relative;
            align-self: flex-start;
            width: 100%;
            max-width: 320px;
        }
        .search-box-wrapper i {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: #aaa;
            transition: color 0.3s ease;
        }
        .search-box {
            padding: 10px 15px 10px 40px;
            border: 2px solid #dee2e6;
            border-radius: 25px;
            font-size: 14px;
            width: 100%;
            transition: border-color 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease, color 0.3s ease;
        }
        
        .search-box:focus {
            outline: none;
            border-color: #ff6b6b;
            box-shadow: 0 0 0 4px rgba(255, 107, 107, 0.25);
        }
        .search-box:focus + i, .search-box-wrapper:focus-within i { 
            color: #ff6b6b;
        }

        .tag-filters-wrapper {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            padding: 8px 0;
            width: 100%;
        }
        .tag-filter-label {
            font-weight: 500;
            color: #333;
            margin-right: 5px;
            transition: color 0.3s ease;
        }
        #tagFiltersContainer {
            display: grid;
            grid-template-rows: auto auto;
            grid-auto-flow: column;
            gap: 8px;
            overflow-x: auto;
            width: 100%;
            padding: 5px 5px 15px 5px;
            -webkit-overflow-scrolling: touch;
        }
        @media (min-width: 1200px) {
            #tagFiltersContainer {
                display: flex;
                flex-wrap: wrap;
                overflow-x: visible;
                padding: 5px 0;
                grid-template-rows: unset;
                grid-auto-flow: unset;
            }
            .control-group {
                display: flex;
                flex-wrap: wrap;
                overflow-x: visible;
                padding-bottom: 0;
                margin-bottom: 0;
                grid-template-rows: unset;
                grid-auto-flow: unset;
            }
        }
        #tagFiltersContainer input[type="checkbox"],
        #tagSelectionCheckboxes input[type="checkbox"] {
            display: none;
        }
        #tagFiltersContainer label,
        #tagSelectionCheckboxes label {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 5px 12px;
            border-radius: 14px;
            font-size: 0.9em;
            font-weight: 500;
            white-space: nowrap;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
            border: 1px solid;
        }
        #tagFiltersContainer label:hover,
        #tagSelectionCheckboxes label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        #tagFiltersContainer label.tag-speed, #tagSelectionCheckboxes label.tag-speed { background-color: #ffe0b2; color: #e65100; border-color: #ffcc80;}
        #tagFiltersContainer label.tag-size, #tagSelectionCheckboxes label.tag-size { background-color: #c8e6c9; color: #1b5e20; border-color: #a5d6a7;}
        #tagFiltersContainer label.tag-versatile, #tagSelectionCheckboxes label.tag-versatile { background-color: #bbdefb; color: #0d47a1; border-color: #90caf9;}
        #tagFiltersContainer label.tag-cpu-tag, #tagSelectionCheckboxes label.tag-cpu-tag { background-color: #fff9c4; color: #f57f17; border-color: #fff59d;}
        #tagFiltersContainer label.tag-compact, #tagSelectionCheckboxes label.tag-compact { background-color: #d1c4e9; color: #311b92; border-color: #b39ddb;}
        #tagFiltersContainer label.tag-gpu, #tagSelectionCheckboxes label.tag-gpu { background-color: #e1f5fe; color: #01579b; border-color: #b3e5fc;}
        #tagFiltersContainer label, #tagSelectionCheckboxes label {
            background-color: #e0e0e0;
            color: #333;
            border-color: #bdbdbd;
        }
        #tagFiltersContainer label.checked,
        #tagSelectionCheckboxes label.checked {
            transform: scale(1.05);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
            filter: brightness(1.1);
            border-width: 2px;
            padding: 4px 11px;
        }
        .table-wrapper {
            overflow-x: auto; 
            margin: 1rem 0; 
            padding: 0 1.5rem; 
            opacity: 0;
            animation: slideUpFadeIn 0.7s ease-out forwards;
            animation-delay: 0.8s; 
        }
        
        .cpu-table {
            width: 100%;
            min-width: 1700px; /* タグ列、チェックボックス列、お気に入り列追加のため */
            border-collapse: collapse;
            background: white;
            transition: background-color 0.3s ease;
        }
        
        .cpu-table th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: bold;
            border-bottom: 0px solid #5a67d8;
            cursor: pointer; 
            position: relative;
            white-space: nowrap; 
            transition: background-color 0.2s ease, display 0s;
        }
        .cpu-table th:hover {
            background: linear-gradient(135deg, #5a67d8, #6a3f9a); 
        }
        .cpu-table th.checkbox-column, .cpu-table th.favorite-column { 
            width: 40px;
            text-align: center;
        }
        .cpu-table th.checkbox-column {
            cursor: default;
        }
        .cpu-table th.checkbox-column:hover {
            background: linear-gradient(135deg, #667eea, #764ba2); /* No hover effect for checkbox header */
        }
        .cpu-table th.checkbox-column input[type="checkbox"] {
            transform: scale(1.4);
            cursor: pointer;
            accent-color: #fff;
        }

        .cpu-table th.favorite-column.active {
            background: linear-gradient(135deg, #feca57, #ff9f43);
        }
        .cpu-table th.favorite-column.active i {
            color: #fff3cd;
        }

        .cpu-table th .sort-indicator {
            font-size: 0.9em;
            margin-left: 8px;
            display: inline-block;
            width: 1em; 
            text-align: center;
        }
        .cpu-table th .sort-indicator i { 
            transition: transform 0.2s ease-in-out, opacity 0.2s ease;
        }
        .cpu-table th:hover .sort-indicator i {
            opacity: 1;
            transform: scale(1.1);
        }
        
        .cpu-table td {
            padding: 15px;
            border-bottom: 1px solid #e9ecef;
            transition: background-color 0.2s ease, transform 0.15s ease-out, display 0s, border-color 0.3s ease;
            vertical-align: middle;
            white-space: nowrap; 
        }
        .cpu-table td.checkbox-cell, .cpu-table td.favorite-cell { 
            text-align: center;
            padding: 15px 10px;
        }
        .cpu-table td.checkbox-cell input[type="checkbox"] {
            transform: scale(1.3);
            cursor: pointer;
            accent-color: #667eea;
        }
        .cpu-table td.favorite-cell .favorite-toggle {
            font-size: 1.5em;
            cursor: pointer;
            color: #ccc; /* Default non-favorite color */
            transition: color 0.2s ease, transform 0.2s ease;
        }
        .cpu-table td.favorite-cell .favorite-toggle:hover {
            transform: scale(1.2);
        }
        .cpu-table td.favorite-cell .favorite-toggle.is-favorite {
            color: #feca57; /* Favorite color */
        }

        .cpu-table td.tags-cell {
            white-space: normal; 
            min-width: 150px;
        }
        
        .cpu-table tr:hover td:not([style*="display: none"]) {
            background-color: #f1f3f5;
        }

        .cpu-table tr.no-data td {
            text-align: center;
            padding: 30px;
            font-size: 1.1rem;
            color: #777;
            transition: none; 
        }
        .cpu-table tr.no-data:hover {
            background-color: transparent; 
        }

        .cpu-name {
            font-weight: bold;
            color: #2d3748;
            font-size: 1.1rem;
            transition: color 0.3s ease;
        }
        
        .creator-name {
            color: #667eea;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        
        .score-cell, .speed-cell {
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease, filter 0.2s ease, box-shadow 0.2s ease;
        }
        
        .score-cell:hover, .speed-cell:hover {
            background-color: #e9f5ff;
            transform: scale(1.05) translateY(-1px); 
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }
        .score-cell:active, .speed-cell:active {
            transform: scale(1.02) translateY(0px); 
            filter: brightness(0.95);
            box-shadow: inset 0 1px 4px rgba(0,0,0,0.1);
        }
        
        .metric-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #2d3748;
            transition: color 0.3s ease;
        }
        
        .metric-label {
            font-size: 0.85rem;
            color: #666;
            margin-top: 2px;
            transition: color 0.3s ease;
        }
        .metric-label .fas { 
            font-size: 0.9em;
            opacity: 0.6;
            margin-left: 4px;
        }
        
        .action-btn {
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease, transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1), filter 0.2s ease;
            margin-right: 5px;
            font-size: 0.9rem;
        }
        .action-btn i {
            margin-right: 5px;
        }

        .details-btn { background: linear-gradient(135deg, #4ecdc4, #44a08d); box-shadow: 0 2px 8px rgba(78, 205, 196, 0.3); }
        .details-btn:hover { transform: translateY(-2px) scale(1.05); box-shadow: 0 4px 12px rgba(78, 205, 196, 0.45); filter: brightness(1.05); }
        
        .edit-btn { background: linear-gradient(135deg, #feca57, #ff9f43); box-shadow: 0 2px 8px rgba(254, 202, 87, 0.3); }
        .edit-btn:hover { transform: translateY(-2px) scale(1.05); box-shadow: 0 4px 12px rgba(254, 202, 87, 0.45); filter: brightness(1.05); }

        .action-btn:active {
            transform: translateY(0px) scale(1);
            filter: brightness(0.92);
            box-shadow: 0 1px 5px rgba(0,0,0,0.2);
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            overflow-y: auto; 
            opacity: 0; 
            transition: opacity 0.3s ease-out, backdrop-filter 0.3s ease-out;
        }
        .modal.visible { 
            opacity: 1;
        }
        .modal.closing { 
            opacity: 0;
            backdrop-filter: blur(0px);
        }
        
        .modal-content {
            background: white;
            margin: 2% auto;
            padding: 0;
            border-radius: 20px;
            width: 90%;
            max-width: 800px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            animation: modalSlideIn 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .modal.closing .modal-content {
            animation: modalSlideOut 0.3s cubic-bezier(0.55, 0.085, 0.68, 0.53) forwards;
        }
                
        .modal-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 25px;
            border-radius: 20px 20px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h2 {
            font-size: 1.8rem;
        }
        .modal-header h2 i {
            margin-right: 10px;
        }
        
        .close {
            color: white;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), color 0.2s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            line-height: 1;
            transform-origin: center;
        }
        
        .close:hover {
            transform: rotate(90deg);
            color: #ffdddd;
        }
        
        .modal-body {
            padding: 30px;
        }
        
        /* --- NEW: Detail Modal Layout --- */
        .cpu-detail-grid-main {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 25px;
        }
        .cpu-detail-grid-sub {
            display: grid;
            grid-template-columns: 1fr;
            gap: 25px;
        }
        @media (max-width: 800px) {
            .cpu-detail-grid-main {
                grid-template-columns: 1fr;
            }
        }
        /* --- END: Detail Modal Layout --- */
        
        .detail-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            border-left: 5px solid #667eea;
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease, background-color 0.3s ease;
        }
        .detail-section:hover {
            transform: translateY(-5px) scale(1.01);
            box-shadow: 0 10px 25px rgba(0,0,0,0.08);
            border-left-color: #ff6b6b; 
        }
        
        .detail-section h3 {
            color: #2d3748;
            margin-bottom: 18px;
            font-size: 1.3rem;
            transition: color 0.3s ease;
        }
        .detail-section h3 i {
            margin-right: 8px;
            color: #667eea;
            transition: color 0.3s ease;
        }
        .detail-section:hover h3 i {
            color: #ff6b6b;
        }
        
        .detail-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px dashed #e0e0e0;
            transition: border-color 0.3s ease;
        }
        .detail-item:last-child {
            border-bottom: none;
        }
        
        .detail-label {
            font-weight: 500;
            color: #4a5568;
            margin-right: 10px; 
            white-space: nowrap;
            transition: color 0.3s ease;
        }
        
        .detail-value {
            font-weight: bold;
            color: #2d3748;
            text-align: right;
            word-break: break-all; 
            transition: color 0.3s ease;
        }
        
        .form-modal .modal-content {
            max-width: 750px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #2d3748;
            transition: color 0.3s ease;
        }
        .form-group label .required-asterisk {
            color: red;
            margin-left: 2px;
        }
        
        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            background-color: #fff;
            color: #333;
            transition: border-color 0.3s ease, box-shadow 0.3s ease, background-color 0.2s ease, color 0.3s ease;
        }
        
        .form-group input:focus, .form-group textarea:focus, .form-group select:focus { 
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.25);
            background-color: #fdfdff;
        }
        .form-group input.is-invalid, .form-group textarea.is-invalid, .form-group select.is-invalid {
            border-color: #e74c3c;
            box-shadow: 0 0 0 4px rgba(231, 76, 60, 0.2);
        }
        .invalid-feedback {
            display: none;
            color: #e74c3c;
            font-size: 0.85rem;
            margin-top: 4px;
            opacity: 0; 
            transform: translateY(-5px); 
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .form-group input.is-invalid ~ .invalid-feedback,
        .form-group textarea.is-invalid ~ .invalid-feedback,
        .form-group select.is-invalid ~ .invalid-feedback {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .form-row-tri { 
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
        }
        
        /* === NEW: Scrollable Form Row for Scores === */
        .form-row-scrollable {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-height: 180px; /* 2行分程度の高さに調整 */
            overflow-y: auto;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            scrollbar-width: thin;
            scrollbar-color: #bdc3c7 #f9f9f9;
        }
        .form-row-scrollable::-webkit-scrollbar {
            width: 8px;
        }
        .form-row-scrollable::-webkit-scrollbar-track {
            background: #f9f9f9;
        }
        .form-row-scrollable::-webkit-scrollbar-thumb {
            background-color: #bdc3c7;
            border-radius: 4px;
        }
        .form-row-scrollable .form-group {
            margin-bottom: 0;
        }
        .form-row-scrollable .form-group label {
            font-size: 0.9em;
            color: #555;
            margin-bottom: 5px;
        }
        /* === END: Scrollable Form Row === */

        .submit-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 14px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
            transition: all 0.3s ease, transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            width: 100%;
        }
        .submit-btn i {
            margin-right: 8px;
        }
        
        .submit-btn:hover {
            transform: translateY(-3px) scale(1.01);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.45);
        }
        .submit-btn:active {
            transform: translateY(-1px) scale(0.99);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.35);
        }

        .high-score { color: #27ae60; font-weight: bold; }
        .medium-score { color: #f39c12; font-weight: bold; }
        .low-score { color: #e74c3c; font-weight: bold; }

        .notification {
            visibility: hidden; 
            opacity: 0;
            position: fixed;
            top: 20px; 
            left: 50%;
            transform: translate(-50%, -50px); 
            padding: 15px 25px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            z-index: 2000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            font-size: 1rem;
            text-align: center;
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.4s ease-out, visibility 0s 0.4s;
        }
        .notification.visible {
            visibility: visible;
            opacity: 1;
            transform: translate(-50%, 0); 
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.4s ease-out, visibility 0s 0s;
        }
        .notification.success { background-color: #2ecc71; }
        .notification.error { background-color: #e74c3c; }
        .notification.info { background-color: #3498db; }
        .notification i { margin-right: 10px; }

        /* Tag Styles */
        .tag-badge {
            display: inline-block;
            background-color: #e0e0e0;
            color: #333;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.78em;
            margin-right: 5px;
            margin-bottom: 5px;
            font-weight: 500;
            white-space: nowrap;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        .tag-badge.tag-speed { background-color: #ffe0b2; color: #e65100; border: 1px solid #ffcc80;}
        .tag-badge.tag-size { background-color: #c8e6c9; color: #1b5e20; border: 1px solid #a5d6a7;}
        .tag-badge.tag-versatile { background-color: #bbdefb; color: #0d47a1; border: 1px solid #90caf9;}
        .tag-badge.tag-cpu-tag { background-color: #fff9c4; color: #f57f17; border: 1px solid #fff59d;}
        .tag-badge.tag-compact { background-color: #d1c4e9; color: #311b92; border: 1px solid #b39ddb;}
        .tag-badge.tag-gpu { background-color: #e1f5fe; color: #01579b; border: 1px solid #b3e5fc;}
        
        .detail-tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        #tagSelectionCheckboxes {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            align-content: flex-start;
            gap: 10px;
            height: 165px;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        /* Comparison Modal Styles */
        #comparisonModal .modal-content { max-width: 1200px; }
        #comparisonModal .modal-body { overflow-x: auto; }
        .comparison-table { width: 100%; border-collapse: collapse; margin-top: 20px; table-layout: fixed; font-size: 0.95em; }
        .comparison-table th, .comparison-table td { border: 1px solid #dee2e6; padding: 10px 12px; text-align: left; vertical-align: top; word-wrap: break-word; transition: border-color 0.3s ease, background-color 0.3s ease, color 0.3s ease; }
        .comparison-table th { background-color: #f8f9fa; font-weight: bold; color: #495057; }
        .comparison-table th:first-child { width: 25%; }
        .comparison-table th:not(:first-child) { width: 37.5%; text-align: center; font-size: 1.05em; }
        .comparison-table td { color: #212529; }
        .comparison-table td.cpu-value-cell { text-align: right; }
        .comparison-table td.tags-cell { white-space: normal; }
        .comparison-better { background-color: #d4edda; color: #155724; font-weight: bold; }
        .comparison-worse { background-color: #f8d7da; color: #721c24; }
        .comparison-equal { background-color: #e2e3e5; color: #383d41; }
        .comparison-na { color: #6c757d; font-style: italic; }
        #comparisonChartContainer { margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 12px; border: 1px solid #e9ecef; position: relative; height: 500px; transition: background-color 0.3s ease, border-color 0.3s ease;}

        /* --- NEW: Description Modal Grid Layout --- */
        #descriptionContent {
            display: grid;
            grid-template-columns: 1fr;
            gap: 25px;
        }
        @media (min-width: 800px) {
            #descriptionContent {
                grid-template-columns: 1fr 1fr;
            }
        }
        /* --- END: Description Modal Grid Layout --- */

        /* Settings Modal Styles */
        #settingsModal .modal-content { max-width: 600px; }
        #settingsModal .modal-body { padding: 20px 30px 30px 30px; }
        .settings-tabs {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            overflow-y: hidden;
            margin-bottom: 20px;
            transition: border-color 0.3s ease;
            -webkit-overflow-scrolling: touch;
        }
        .tab-link {
            display: flex;
            align-items: center;
            flex-shrink: 0;
            white-space: nowrap;
            background-color: transparent;
            border: none;
            border-bottom: 2px solid #dee2e6;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 1.05rem;
            font-weight: 500;
            color: #495057;
            position: relative;
            transition: color 0.2s, background-color 0.2s;
            border-radius: 8px 8px 0 0;
        }
        .tab-link i {
            margin-right: 8px;
        }
        .tab-link:hover { color: #667eea; background-color: #f1f3f5; }
        .tab-link.active { color: #667eea; font-weight: bold; border-bottom-color: #667eea; }
        .settings-tab-content { display: none; animation: fadeIn 0.5s; }
        .settings-tab-content h3 { margin-bottom: 15px; font-size: 1.2rem; color: #2d3748; padding-bottom: 10px; border-bottom: 1px solid #e9ecef; transition: color 0.3s ease, border-color 0.3s ease;}
        .column-settings-list, .chart-settings-list { list-style: none; padding: 0; margin: 0; display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .column-settings-list li, .chart-settings-list li {
            background-color: #f8f9fa;
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            transition: background-color 0.2s, border-color 0.2s;
            overflow-x: auto;
            /* Custom Scrollbar for Firefox */
            scrollbar-width: thin;
            scrollbar-color: #bdc3c7 #f8f9fa;
        }
        .column-settings-list li:hover, .chart-settings-list li:hover { background-color: #f1f3f5; border-color: #dee2e6; }
        /* Custom Scrollbar for Webkit browsers */
        .column-settings-list li::-webkit-scrollbar, .chart-settings-list li::-webkit-scrollbar {
            height: 6px;
        }
        .column-settings-list li::-webkit-scrollbar-track, .chart-settings-list li::-webkit-scrollbar-track {
            background: #f8f9fa;
        }
        .column-settings-list li::-webkit-scrollbar-thumb, .chart-settings-list li::-webkit-scrollbar-thumb {
            background-color: #bdc3c7;
            border-radius: 3px;
        }
        .column-settings-list label, .chart-settings-list label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-weight: 500;
            color: #333;
            transition: color 0.3s ease;
            white-space: nowrap;
        }
        .column-settings-list input[type="checkbox"], .chart-settings-list input[type="checkbox"] { margin-right: 10px; transform: scale(1.2); accent-color: #667eea; }
        .scatter-plot-settings-grid { display: grid; grid-template-columns: 1fr; gap: 20px; }
        .settings-actions { margin-top: 25px; text-align: right; }
        .settings-actions .save-settings-btn { background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: all 0.3s ease; }
        .settings-actions .save-settings-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3); }

        /* --- NEW: Score Settings Tab Styles --- */
        .score-settings-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 25px;
        }
        @media (min-width: 700px) {
            .score-settings-container {
                grid-template-columns: 1fr 1fr;
            }
        }
        .score-setting-item {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }
        .score-setting-item h4 {
            margin: 0 0 15px 0;
            font-size: 1.1rem;
            color: #333;
        }
        .score-setting-item .form-group {
            margin-bottom: 15px;
        }
        .score-setting-item .form-group:last-child {
            margin-bottom: 0;
        }
        .behavior-toggle-btn {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ccc;
            background-color: #e9ecef;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .behavior-toggle-btn:hover {
            border-color: #667eea;
            background-color: #e2e6ea;
        }
        .behavior-toggle-btn.high-is-better {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        .behavior-toggle-btn.low-is-better {
            background-color: #cce5ff;
            border-color: #b8daff;
            color: #004085;
        }
        /* --- END: Score Settings Tab Styles --- */

        /* New styles for theme selection */
        .theme-selection-group {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        .theme-selection-group label {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 50%;
        }
        .theme-selection-group label:hover {
            background-color: #f1f3f5;
            border-color: #667eea;
        }
        .theme-selection-group input[type="radio"] {
            display: none; /* Hide the actual radio button */
        }
        .theme-selection-group i {
            margin-right: 10px;
            font-size: 1.2em;
        }
        .theme-selection-group label.checked {
            border-color: #667eea;
            background-color: #e9eafc;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
            font-weight: bold;
            color: #667eea;
        }

        /* Scatter Plot Modal Styles */
        #scatterPlotModal .modal-content { max-width: 1000px; }
        #scatterPlotCanvasContainer { position: relative; height: 60vh; background: #f8f9fa; border-radius: 12px; border: 1px solid #e9ecef; padding: 20px; transition: background-color 0.3s ease, border-color 0.3s ease; }
        #scatterPlotCanvas { cursor: pointer; }

        /* Tag Management Styles */
        .tag-management-container { max-height: 400px; overflow-y: auto; padding-right: 10px; }
        .tag-management-add-form { display: flex; gap: 10px; margin-bottom: 20px; }
        .tag-management-add-form input { flex-grow: 1; }
        .tag-management-add-form button { white-space: nowrap; padding: 12px 18px; background: #2ecc71; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; }
        .tag-management-add-form button:hover { background: #27ae60; }
        .tag-management-list { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 10px; }
        .tag-management-item { display: flex; align-items: center; justify-content: space-between; background-color: #f8f9fa; padding: 10px 15px; border-radius: 8px; border: 1px solid #e9ecef; transition: background-color 0.2s, border-color 0.2s; }
        .tag-item-name { font-weight: 500; color: #333; }
        .tag-item-actions button { background: none; border: none; cursor: pointer; font-size: 1.1em; margin-left: 10px; padding: 5px; border-radius: 5px; transition: background-color 0.2s, color 0.2s; }
        .tag-item-actions .edit-tag-btn { color: #3498db; }
        .tag-item-actions .edit-tag-btn:hover { background-color: #eaf5fc; }
        .tag-item-actions .delete-tag-btn { color: #e74c3c; }
        .tag-item-actions .delete-tag-btn:hover { background-color: #fbecec; }
        .tag-edit-form { display: flex; align-items: center; gap: 8px; width: 100%; }
        .tag-edit-input { flex-grow: 1; padding: 8px; border: 1px solid #ccc; border-radius: 5px; }
        .tag-edit-form .save-tag-btn { color: #2ecc71; }
        .tag-edit-form .cancel-tag-btn { color: #95a5a6; }

        /* Statistics Modal Styles */
        #statisticsModal .modal-content { max-width: 1100px; }
        .stats-main-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        .stats-info-column .stats-card {
            height: 100%;
        }
        .stats-charts-column {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        .stats-card {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            border-left: 5px solid #1abc9c;
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease, background-color 0.3s ease;
        }
        .stats-card:hover {
            transform: translateY(-5px) scale(1.01);
            box-shadow: 0 10px 25px rgba(0,0,0,0.08);
        }
        .stats-card h3 {
            margin: 0 0 18px 0;
            font-size: 1.3rem;
            color: #2d3748;
            transition: color 0.3s ease;
        }
        .stats-card h3 i {
            margin-right: 8px;
            color: #1abc9c;
        }
        .stats-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            font-size: 0.95rem;
            border-bottom: 1px dashed #e0e0e0;
            transition: border-color 0.3s ease;
            flex-wrap: wrap;
            gap: 5px;
        }
        .stats-item:last-child { border-bottom: none; }
        .stats-label { color: #4a5568; transition: color 0.3s ease; }
        .stats-value { font-weight: bold; color: #2d3748; transition: color 0.3s ease; text-align: right; }
        .stats-card hr {
            border: 0;
            border-top: 1px dashed #e0e0e0;
            margin: 15px 0;
        }
        .stats-chart-wrapper {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            min-height: 280px;
            border: 1px solid #e9ecef;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        @media (max-width: 900px) {
            .stats-main-container {
                grid-template-columns: 1fr;
            }
        }


        /* === Dark Theme Styles (Tokyo Night inspired) === */
        body.dark-theme {
            background: linear-gradient(135deg, #1f2335 0%, #141622 100%);
            color: #c0caf5;
        }
        .dark-theme .container {
            background: rgba(36, 40, 59, 0.98);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        .dark-theme header {
             background: linear-gradient(135deg, #3b4261, #1e202e);
        }
        .dark-theme .controls {
            background: #24283b;
            border-bottom: 1px solid #3b4261;
        }
        .dark-theme .search-box {
            background-color: #1a1b26;
            border-color: #414868;
            color: #c0caf5;
        }
        .dark-theme .search-box:focus {
            border-color: #7aa2f7;
            box-shadow: 0 0 0 4px rgba(122, 162, 247, 0.25);
        }
        .dark-theme .search-box:focus + i, .dark-theme .search-box-wrapper:focus-within i {
            color: #7aa2f7;
        }
        .dark-theme .tag-filter-label {
            color: #c0caf5;
        }
        
        .dark-theme #tagFiltersContainer label,
        .dark-theme #tagSelectionCheckboxes label {
            background-color: #2f354e;
            color: #a9b1d6;
            border-color: #414868;
        }
        .dark-theme #tagFiltersContainer label:hover,
        .dark-theme #tagSelectionCheckboxes label:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            color: #c0caf5;
            border-color: #7aa2f7;
        }
        .dark-theme #tagFiltersContainer label.checked,
        .dark-theme #tagSelectionCheckboxes label.checked {
            filter: brightness(1.2);
            border-color: #c0caf5;
            color: #c0caf5;
        }
        .dark-theme #tagFiltersContainer label.tag-speed, .dark-theme #tagSelectionCheckboxes label.tag-speed { background-color: #563d2c; color: #ff9e64; border-color: #7d5a44; }
        .dark-theme #tagFiltersContainer label.tag-size, .dark-theme #tagSelectionCheckboxes label.tag-size { background-color: #3c522e; color: #9ece6a; border-color: #5a7946; }
        .dark-theme #tagFiltersContainer label.tag-versatile, .dark-theme #tagSelectionCheckboxes label.tag-versatile { background-color: #334a70; color: #7aa2f7; border-color: #4f6a92; }
        .dark-theme #tagFiltersContainer label.tag-cpu-tag, .dark-theme #tagSelectionCheckboxes label.tag-cpu-tag { background-color: #5a482c; color: #e0af68; border-color: #826a44; }
        .dark-theme #tagFiltersContainer label.tag-compact, .dark-theme #tagSelectionCheckboxes label.tag-compact { background-color: #493e6a; color: #bb9af7; border-color: #6a5a8f; }
        .dark-theme #tagFiltersContainer label.tag-gpu, .dark-theme #tagSelectionCheckboxes label.tag-gpu { background-color: #31575e; color: #73daca; border-color: #4f7e86; }

        .dark-theme .cpu-table {
            background: #24283b;
        }
        .dark-theme .cpu-table th {
            background: linear-gradient(135deg, #3b4261, #292e42);
            border-bottom-color: #414868;
        }
        .dark-theme .cpu-table th:hover {
            background: linear-gradient(135deg, #414868, #3b4261);
        }
        .dark-theme .cpu-table th.checkbox-column:hover {
             background: linear-gradient(135deg, #3b4261, #292e42);
        }
        .dark-theme .cpu-table th.favorite-column.active {
            background: linear-gradient(135deg, #e0af68, #c6954b);
        }
        .dark-theme .cpu-table th.favorite-column.active i {
            color: #1a1b26;
        }
        .dark-theme .cpu-table td {
            border-bottom-color: #3b4261;
        }
        .dark-theme .cpu-table tr:hover td:not([style*="display: none"]) {
            background-color: #2f354e;
        }
        .dark-theme .cpu-table tr.no-data td {
            color: #a9b1d6;
        }
        .dark-theme .cpu-name { color: #c0caf5; }
        .dark-theme .creator-name { color: #7aa2f7; }
        .dark-theme .metric-value { color: #c0caf5; }
        .dark-theme .metric-label { color: #bb9af7; }
        .dark-theme .score-cell:hover, .dark-theme .speed-cell:hover {
            background-color: #2f354e;
        }
        .dark-theme td.favorite-cell .favorite-toggle {
            color: #545c7e;
        }
        .dark-theme td.favorite-cell .favorite-toggle.is-favorite {
            color: #ffc777;
        }
        .dark-theme .modal {
            background-color: rgba(10, 11, 16, 0.75);
            backdrop-filter: blur(6px);
        }
        .dark-theme .modal-content {
            background: #24283b;
            color: #c0caf5;
        }
        .dark-theme .modal-header {
            background: linear-gradient(135deg, #3b4261, #292e42);
        }
        .dark-theme .detail-section {
            background: #1a1b26;
            border-left-color: #bb9af7;
        }
        .dark-theme .detail-section:hover {
             border-left-color: #73daca;
        }
        .dark-theme .detail-section h3 { color: #c0caf5; }
        .dark-theme .detail-section h3 i { color: #bb9af7; }
        .dark-theme .detail-section:hover h3 i { color: #73daca; }
        .dark-theme .detail-item { border-bottom-color: #414868; }
        .dark-theme .detail-label { color: #a9b1d6; }
        .dark-theme .detail-value { color: #c0caf5; }
        .dark-theme p { color: #c0caf5; }
        .dark-theme .form-group label { color: #c0caf5; }
        .dark-theme .form-group input, .dark-theme .form-group textarea, .dark-theme .form-group select {
            background-color: #16161e;
            border-color: #414868;
            color: #c0caf5;
        }
        .dark-theme .form-group input:focus, .dark-theme .form-group textarea:focus, .dark-theme .form-group select:focus {
            border-color: #7aa2f7;
            box-shadow: 0 0 0 4px rgba(122, 162, 247, 0.25);
            background-color: #1a1b26;
        }
        .dark-theme .form-row-scrollable {
            background-color: #16161e;
            border-color: #414868;
            scrollbar-color: #414868 #16161e;
        }
        .dark-theme .form-row-scrollable::-webkit-scrollbar-track {
            background: #16161e;
        }
        .dark-theme .form-row-scrollable::-webkit-scrollbar-thumb {
            background-color: #414868;
        }
        .dark-theme #tagSelectionCheckboxes {
            background-color: #16161e;
            border-color: #414868;
        }
        .dark-theme .comparison-table th, .dark-theme .comparison-table td { border-color: #414868; }
        .dark-theme .comparison-table th { background-color: #2f354e; color: #c0caf5; }
        .dark-theme .comparison-table td { color: #c0caf5; }
        .dark-theme .comparison-better { background-color: rgba(158, 206, 106, 0.15); color: #9ece6a; }
        .dark-theme .comparison-worse { background-color: rgba(247, 118, 142, 0.15); color: #f7768e; }
        .dark-theme .comparison-equal { background-color: #2f354e; color: #c0caf5; }
        .dark-theme .comparison-na { color: #a9b1d6; }
        .dark-theme #comparisonChartContainer { background: #1a1b26; border-color: #414868; }
        .dark-theme #comparisonChartContainer .scales .r .pointLabels { color: '#c0caf5'; }
        .dark-theme .settings-tabs {
            border-bottom-color: #414868;
        }
        .dark-theme .tab-link { color: #a9b1d6; }
        .dark-theme .tab-link:hover { color: #7aa2f7; background-color: #2f354e; }
        .dark-theme .tab-link.active { color: #7aa2f7; border-bottom-color: #7aa2f7;}
        .dark-theme .settings-tab-content h3 { color: #c0caf5; border-bottom-color: #414868; }
        .dark-theme .column-settings-list li, .dark-theme .chart-settings-list li {
            background-color: #2f354e;
            border-color: #414868;
            scrollbar-color: #414868 #2f354e;
        }
        .dark-theme .column-settings-list li::-webkit-scrollbar-track, .dark-theme .chart-settings-list li::-webkit-scrollbar-track {
            background: #2f354e;
        }
        .dark-theme .column-settings-list li::-webkit-scrollbar-thumb, .dark-theme .chart-settings-list li::-webkit-scrollbar-thumb {
            background-color: #414868;
        }
        .dark-theme .column-settings-list label, .dark-theme .chart-settings-list label { color: #c0caf5; }
        .dark-theme .theme-selection-group label {
            border-color: #414868;
            color: #c0caf5;
        }
        .dark-theme .theme-selection-group label:hover {
            background-color: #2f354e;
            border-color: #7aa2f7;
        }
        .dark-theme .theme-selection-group label.checked {
            border-color: #7aa2f7;
            background-color: #1a1b26;
            box-shadow: 0 2px 8px rgba(122, 162, 247, 0.2);
            color: #7aa2f7;
        }
        .dark-theme .tag-badge { background-color: #2f354e; color: #a9b1d6; border: 1px solid #414868; }
        .dark-theme .tag-badge.tag-speed { background-color: #563d2c; color: #ff9e64; border-color: #7d5a44; }
        .dark-theme .tag-badge.tag-size { background-color: #3c522e; color: #9ece6a; border-color: #5a7946; }
        .dark-theme .tag-badge.tag-versatile { background-color: #334a70; color: #7aa2f7; border-color: #4f6a92; }
        .dark-theme .tag-badge.tag-cpu-tag { background-color: #5a482c; color: #e0af68; border-color: #826a44; }
        .dark-theme .tag-badge.tag-compact { background-color: #493e6a; color: #bb9af7; border-color: #6a5a8f; }
        .dark-theme .tag-badge.tag-gpu { background-color: #31575e; color: #73daca; border-color: #4f7e86; }
        .dark-theme #scatterPlotCanvasContainer { background: #1a1b26; border-color: #414868; }
        /* Dark Theme for Tag Management */
        .dark-theme .tag-management-add-form button { background: #9ece6a; color: #1a1b26; }
        .dark-theme .tag-management-add-form button:hover { background: #8ab959; }
        .dark-theme .tag-management-item { background-color: #2f354e; border-color: #414868; }
        .dark-theme .tag-item-name { color: #c0caf5; }
        .dark-theme .tag-item-actions .edit-tag-btn { color: #7aa2f7; }
        .dark-theme .tag-item-actions .edit-tag-btn:hover { background-color: #24283b; }
        .dark-theme .tag-item-actions .delete-tag-btn { color: #f7768e; }
        .dark-theme .tag-item-actions .delete-tag-btn:hover { background-color: #24283b; }
        .dark-theme .tag-edit-input { background-color: #1a1b26; border-color: #414868; color: #c0caf5; }
        .dark-theme .tag-edit-form .save-tag-btn { color: #9ece6a; }
        .dark-theme .tag-edit-form .cancel-tag-btn { color: #a9b1d6; }
        /* Dark Theme for Score Settings */
        .dark-theme .score-setting-item {
            background-color: #2f354e;
            border-color: #414868;
        }
        .dark-theme .score-setting-item h4 {
            color: #c0caf5;
        }
        .dark-theme .behavior-toggle-btn {
            background-color: #24283b;
            border-color: #414868;
            color: #c0caf5;
        }
        .dark-theme .behavior-toggle-btn:hover {
            border-color: #7aa2f7;
        }
        .dark-theme .behavior-toggle-btn.high-is-better {
            background-color: rgba(158, 206, 106, 0.15);
            border-color: #9ece6a;
            color: #9ece6a;
        }
        .dark-theme .behavior-toggle-btn.low-is-better {
            background-color: rgba(122, 162, 247, 0.15);
            border-color: #7aa2f7;
            color: #7aa2f7;
        }
        /* Dark Theme for Statistics Modal */
        .dark-theme .stats-card {
            background: #1a1b26;
            border-left-color: #73daca;
            border-color: #414868;
        }
        .dark-theme .stats-card h3 { color: #c0caf5; }
        .dark-theme .stats-card h3 i { color: #73daca; }
        .dark-theme .stats-item { border-bottom-color: #414868; }
        .dark-theme .stats-label { color: #a9b1d6; }
        .dark-theme .stats-value { color: #c0caf5; }
        .dark-theme .stats-card hr { border-top-color: #414868; }
        .dark-theme .stats-chart-wrapper {
            background: #24283b;
            border-color: #414868;
        }
    </style>
</head>
<body>
    <div id="notification" class="notification"></div>

    <div class="container">
        <header>
            <h1 class="header-title"><i class="fas fa-microchip"></i> 自作CPU/GPU性能比較サイト</h1>
            <p class="header-subtitle">あなたの自作デバイスの性能を比較・共有しよう</p>
        </header>
        
        <div class="controls">
            <div class="control-group">
                <button class="add-cpu-btn" onclick="openCpuFormModal(null)"><i class="fas fa-plus"></i> 新規追加</button>
                <button id="compareSelectedBtn" class="compare-selected-btn" onclick="openComparisonModal()" disabled><i class="fas fa-balance-scale"></i> 比較 (<span class="selected-count">0</span>/2)</button>
                <button id="deleteSelectedBtn" class="delete-selected-btn" onclick="deleteSelectedCPUs()" disabled><i class="fas fa-trash-alt"></i> まとめて削除 (<span class="selected-count">0</span>)</button>
                <button class="info-btn" onclick="openDescriptionModal()"><i class="fas fa-info-circle"></i> スコア説明</button>
                <button class="scatter-plot-btn" onclick="openScatterPlotModal()"><i class="fas fa-braille"></i> 散布図</button>
                <button class="statistics-btn" onclick="openStatisticsModal()"><i class="fas fa-chart-bar"></i> 統計情報</button>
                <button class="settings-btn" onclick="openSettingsModal()"><i class="fas fa-cog"></i> 設定</button>
                <button class="export-btn" onclick="exportDataAsJSON()"><i class="fas fa-file-export"></i> エクスポート</button>
                <label for="import-json-input" class="import-btn"><i class="fas fa-file-import"></i> インポート</label>
                <input type="file" id="import-json-input" accept=".json" style="display: none;">
            </div>
            <div class="search-box-wrapper">
                <i class="fas fa-search"></i>
                <input type="text" class="search-box" placeholder="デバイス名、製作者などで検索..." oninput="filterCPUs()">
            </div>
        </div>
        <div class="controls" style="border-top: 1px solid #e9ecef; padding-top:1rem; margin-top:-1px;">
             <div class="tag-filters-wrapper">
                <span class="tag-filter-label"><i class="fas fa-tags"></i> タグフィルター
                </span>
                <div id="tagFiltersContainer">
                    <!-- Tag checkboxes will be dynamically inserted here -->
                </div>
            </div>
        </div>
        
        <div class="table-wrapper">
            <table class="cpu-table" id="cpuTable">
                <thead>
                    <tr>
                        <th data-column-key="favorite" class="favorite-column" title="お気に入りのみ表示/非表示 (クリックで切替)"><i class="fas fa-star"></i></th>
                        <th data-column-key="checkbox" class="checkbox-column"><input type="checkbox" id="selectAllCheckbox" title="すべて選択/選択解除"></th>
                        <th data-column-key="creator" data-sort-key="creator" title="製作者名でソート (クリックで昇順/降順/ソートなし切り替え)">製作者<span class="sort-indicator"></span></th>
                        <th data-column-key="name" data-sort-key="name" title="デバイス名でソート (クリックで昇順/降順/ソートなし切り替え)">デバイス名<span class="sort-indicator"></span></th>
                        <th data-column-key="scores" data-sort-key="scores" title="スコアでソート (クリックで昇順/降順/ソートなし切り替え)">スコア (tick)<span class="sort-indicator"></span></th>
                        <th data-column-key="speeds" data-sort-key="speeds" title="速度でソート (クリックで昇順/降順/ソートなし切り替え)">速度 (OPS)<span class="sort-indicator"></span></th>
                        <th data-column-key="cores" data-sort-key="cores" title="コア数でソート (クリックで昇順/降順/ソートなし切り替え)">コア数<span class="sort-indicator"></span></th>
                        <th data-column-key="threads" data-sort-key="threads" title="スレッド数でソート (クリックで昇順/降順/ソートなし切り替え)">スレッド数<span class="sort-indicator"></span></th>
                        <th data-column-key="bit" data-sort-key="bit" title="データ幅でソート (クリックで昇順/降順/ソートなし切り替え)">データ幅<span class="sort-indicator"></span></th>
                        <th data-column-key="volume" data-sort-key="volume" title="体積でソート (クリックで昇順/降順/ソートなし切り替え)">体積 (ブロック³)<span class="sort-indicator"></span></th>
                        <th data-column-key="completionDate" data-sort-key="completionDate" title="完成日でソート (クリックで昇順/降順/ソートなし切り替え)">完成日<span class="sort-indicator"></span></th>
                        <th data-column-key="tags">タグ</th>
                        <th data-column-key="actions">操作</th>
                    </tr>
                </thead>
                <tbody id="cpuTableBody">
                    <!-- CPU/GPUデータがここに表示される -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- 詳細モーダル -->
    <div id="detailModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="detailTitle">デバイス詳細情報</h2>
                <span class="close" onclick="closeModal('detailModal')">&times;</span>
            </div>
            <div class="modal-body" id="detailContent">
                <!-- 詳細情報がここに表示される -->
            </div>
        </div>
    </div>

    <!-- 追加/編集モーダル -->
    <div id="cpuFormModal" class="modal form-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="cpuFormTitle">新しいデバイスを追加</h2>
                <span class="close" onclick="closeModal('cpuFormModal')">&times;</span>
            </div>
            <div class="modal-body">
                <form id="cpuForm">
                    <input type="hidden" id="editingCpuId">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="creator">製作者<span class="required-asterisk">*</span></label>
                            <input type="text" id="creator" required>
                            <div class="invalid-feedback">製作者名は必須です。</div>
                        </div>
                        <div class="form-group">
                            <label for="cpuName">デバイス名<span class="required-asterisk">*</span></label>
                            <input type="text" id="cpuName" required>
                            <div class="invalid-feedback">デバイス名は必須です。</div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>スコア (単位: tick / 未入力可)</label>
                        <div id="newScoreFieldsContainer" class="form-row-scrollable">
                            <!-- New score fields will be dynamically inserted here -->
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="microarchitecture">マイクロアーキテクチャ</label>
                        <input type="text" id="microarchitecture" placeholder="例: Pipelined CISC / Custom Shader Core">
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label for="multiSpeed">マルチ最大演算能力 (OPS)<span class="required-asterisk">*</span></label>
                            <input type="number" step="0.0001" id="multiSpeed" required min="0">
                            <div class="invalid-feedback">マルチ最大演算能力は0以上の数値で入力してください (小数点第4位まで)。</div>
                        </div>
                        <div class="form-group">
                            <label for="singleSpeed">シングル最大演算能力 (OPS)<span class="required-asterisk">*</span></label>
                            <input type="number" step="0.0001" id="singleSpeed" required min="0">
                            <div class="invalid-feedback">シングル最大演算能力は0以上の数値で入力してください (小数点第4位まで)。</div>
                        </div>
                    </div>
                    
                    <div class="form-row">
                         <div class="form-group">
                            <label for="branchSpeed">シングル条件分岐演算能力 (OPS)</label>
                            <input type="number" step="0.0001" id="branchSpeed" min="0" placeholder="未測定の場合は空欄">
                            <div class="invalid-feedback">シングル条件分岐演算能力は0以上の数値で入力してください (小数点第4位まで)。</div>
                        </div>
                    </div>

                    <hr style="margin: 25px 0; border-top: 1px solid #e2e8f0;">
                    <h3 style="margin-bottom: 20px; color: #2d3748; font-size: 1.4rem;"><i class="fas fa-cogs"></i> 追加情報</h3>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="cores">コア数<span class="required-asterisk">*</span></label>
                            <input type="number" id="cores" min="1" required>
                            <div class="invalid-feedback">コア数は1以上の整数で入力してください。</div>
                        </div>
                        <div class="form-group">
                            <label for="threads">スレッド数<span class="required-asterisk">*</span></label>
                            <input type="number" id="threads" min="1" required>
                            <div class="invalid-feedback">スレッド数は1以上の整数で入力してください。</div>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="minecraftEdition">マイクラEdition<span class="required-asterisk">*</span></label>
                            <select id="minecraftEdition" required>
                                <option value="">選択してください</option>
                                <option value="Java">Java Edition</option>
                                <option value="Bedrock">Bedrock Edition</option>
                                <option value="Other">その他</option>
                            </select>
                            <div class="invalid-feedback">マイクラEditionを選択してください。</div>
                        </div>
                        <div class="form-group">
                            <label for="bit">データ幅<span class="required-asterisk">*</span></label>
                            <input type="number" id="bit" placeholder="例: 64" min="1" required>
                            <div class="invalid-feedback">データ幅は1以上の整数で入力してください。</div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="completionDate">完成日<span class="required-asterisk">*</span></label>
                        <input type="date" id="completionDate" required>
                        <div class="invalid-feedback">完成日を入力してください。</div>
                    </div>
                    
                    <div class="form-group">
                        <label>体積<span class="required-asterisk">*</span></label>
                        <div class="form-row-tri">
                            <div>
                                <label for="volumeX" style="font-size:0.9em; color:#555;">X (幅)</label>
                                <input type="number" id="volumeX" placeholder="X" min="1" required>
                                <div class="invalid-feedback">幅は1以上の整数で。</div>
                            </div>
                            <div>
                                <label for="volumeY" style="font-size:0.9em; color:#555;">Y (高さ)</label>
                                <input type="number" id="volumeY" placeholder="Y" min="1" required>
                                <div class="invalid-feedback">高さは1以上の整数で。</div>
                            </div>
                            <div>
                                <label for="volumeZ" style="font-size:0.9em; color:#555;">Z (奥行き)</label>
                                <input type="number" id="volumeZ" placeholder="Z" min="1" required>
                                <div class="invalid-feedback">奥行きは1以上の整数で。</div>
                            </div>
                        </div>
                        <div id="calculatedVolumeDisplay" style="margin-top: 8px; font-size: 0.9em; color: #333;">合計体積: -</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="description">説明</label>
                        <textarea id="description" rows="4" placeholder="デバイスの特徴、開発の苦労話"></textarea>
                    </div>

                    <div class="form-group">
                        <label><i class="fas fa-tags"></i> タグ</label>
                        <div id="tagSelectionCheckboxes">
                            <!-- Tag checkboxes will be dynamically inserted here -->
                        </div>
                    </div>
                    
                    <button type="submit" class="submit-btn" id="cpuFormSubmitBtn"><i class="fas fa-plus-circle"></i> デバイスを追加</button>
                </form>
            </div>
        </div>
    </div>

    <!-- 比較モーダル -->
    <div id="comparisonModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="comparisonTitle">デバイス比較</h2>
                <span class="close" onclick="closeModal('comparisonModal')">&times;</span>
            </div>
            <div class="modal-body" id="comparisonContent">
                <!-- 比較情報がここに表示される -->
            </div>
        </div>
    </div>

    <!-- スコア説明モーダル -->
    <div id="descriptionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-book-open"></i> スコア説明</h2>
                <span class="close" onclick="closeModal('descriptionModal')">&times;</span>
            </div>
            <div class="modal-body" id="descriptionContent" style="max-height: 70vh; overflow-y: auto;">
                <!-- スコア説明がここに表示される -->
            </div>
        </div>
    </div>

    <!-- 散布図モーダル -->
    <div id="scatterPlotModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-braille"></i> 性能散布図</h2>
                <span class="close" onclick="closeModal('scatterPlotModal')">&times;</span>
            </div>
            <div class="modal-body">
                <div id="scatterPlotCanvasContainer">
                    <canvas id="scatterPlotCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- 統計情報モーダル -->
    <div id="statisticsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-chart-bar"></i> 統計情報</h2>
                <span class="close" onclick="closeModal('statisticsModal')">&times;</span>
            </div>
            <div class="modal-body" id="statisticsContent">
                <!-- 統計情報がここに表示される -->
            </div>
        </div>
    </div>

    <!-- 設定モーダル -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-cog"></i> 設定</h2>
                <span class="close" onclick="closeModal('settingsModal')">&times;</span>
            </div>
            <div class="modal-body">
                <div class="settings-tabs">
                    <button class="tab-link active" onclick="openSettingsTab(event, 'columnSettingsTab')"><i class="fas fa-table"></i>表示列</button>
                    <button class="tab-link" onclick="openSettingsTab(event, 'chartSettingsTab')"><i class="fas fa-chart-pie"></i>比較グラフ</button>
                    <button class="tab-link" onclick="openSettingsTab(event, 'scoreSettingsTab')"><i class="fas fa-ruler-combined"></i>スコア設定</button>
                    <button class="tab-link" onclick="openSettingsTab(event, 'scatterPlotSettingsTab')"><i class="fas fa-braille"></i>散布図</button>
                    <button class="tab-link" onclick="openSettingsTab(event, 'tagManagementTab')"><i class="fas fa-tags"></i>タグ管理</button>
                    <button class="tab-link" onclick="openSettingsTab(event, 'appearanceSettingsTab')"><i class="fas fa-palette"></i>見た目</button>
                </div>

                <div id="columnSettingsTab" class="settings-tab-content" style="display: block;">
                    <h3>テーブルに表示する列を選択</h3>
                    <ul id="columnSettingsList" class="column-settings-list">
                        <!-- Column checkboxes will be dynamically inserted here -->
                    </ul>
                </div>

                <div id="chartSettingsTab" class="settings-tab-content">
                    <h3>比較グラフに表示する項目を選択</h3>
                    <ul id="chartSettingsList" class="chart-settings-list">
                        <!-- Chart item checkboxes will be dynamically inserted here -->
                    </ul>
                </div>

                <div id="scoreSettingsTab" class="settings-tab-content">
                    <h3>各スコアの評価基準と閾値を設定</h3>
                    <div id="scoreSettingsContainer" class="score-settings-container">
                        <!-- Score settings will be dynamically inserted here -->
                    </div>
                </div>

                <div id="scatterPlotSettingsTab" class="settings-tab-content">
                    <h3>散布図の軸とサイズを選択</h3>
                    <div class="scatter-plot-settings-grid">
                        <div class="form-group">
                            <label for="scatterXAxis">X軸</label>
                            <select id="scatterXAxis" class="form-group select"></select>
                        </div>
                        <div class="form-group">
                            <label for="scatterYAxis">Y軸</label>
                            <select id="scatterYAxis" class="form-group select"></select>
                        </div>
                        <div class="form-group">
                            <label for="scatterBubbleSize">バブルサイズ</label>
                            <select id="scatterBubbleSize" class="form-group select"></select>
                        </div>
                    </div>
                </div>

                <div id="tagManagementTab" class="settings-tab-content">
                    <h3>タグの管理</h3>
                    <div class="tag-management-container">
                        <div class="form-group">
                            <label for="newTagName">新しいタグを追加</label>
                            <div class="tag-management-add-form">
                                <input type="text" id="newTagName" placeholder="タグ名を入力...">
                                <button onclick="addNewTag()"><i class="fas fa-plus"></i> 追加</button>
                            </div>
                        </div>
                        <ul id="tagManagementList" class="tag-management-list">
                            <!-- Tag management list will be dynamically inserted here -->
                        </ul>
                    </div>
                </div>

                <div id="appearanceSettingsTab" class="settings-tab-content">
                    <h3>テーマ設定</h3>
                    <div class="form-group">
                        <label>サイトのテーマを選択してください</label>
                        <div id="themeSelectionContainer" class="theme-selection-group">
                            <!-- Theme radio buttons will be dynamically inserted here -->
                        </div>
                    </div>
                </div>

                <div class="settings-actions">
                    <button class="save-settings-btn" onclick="saveAllSettingsAndCloseModal()"><i class="fas fa-save"></i> 設定を保存して閉じる</button>
                </div>
            </div>
        </div>
    </div>


    <script>
        const LOCAL_STORAGE_DATA_KEY = 'customCpuSiteData_v2_5_scores';
        const LOCAL_STORAGE_SORT_KEY = 'customCpuSiteSortState_v2_4_favorite';
        const LOCAL_STORAGE_FAVORITE_FILTER_KEY = 'customCpuSiteFavoriteFilterState_v2_4';
        const LOCAL_STORAGE_COLUMN_VISIBILITY_KEY = 'customCpuSiteColumnVisibility_v1';
        const LOCAL_STORAGE_CHART_VISIBILITY_KEY = 'customCpuSiteChartVisibility_v1';
        const LOCAL_STORAGE_THEME_KEY = 'customCpuSiteTheme_v1';
        const LOCAL_STORAGE_SCATTER_KEY = 'customCpuSiteScatterSettings_v1';
        const LOCAL_STORAGE_TAGS_KEY = 'customCpuSiteTags_v1';
        const LOCAL_STORAGE_SCORE_SETTINGS_KEY = 'customCpuSiteScoreSettings_v2'; // Updated key for new score settings

        let AVAILABLE_TAGS = [];

        const SCORE_DEFINITIONS = {
            rcbsp: { label: 'RCBSP' },
            rcbfa: { label: 'RCBFA' },
            rcbmp: { label: 'RCBMP' },
            rcbwm: { label: 'RCBWM' },
            rcbrm: { label: 'RCBRM' },
            rcbml: { label: 'RCBML' },
            rcbdv: { label: 'RCBDV' },
            rcbsq: { label: 'RCBSQ' },
            rcbsh: { label: 'RCBSH' },
        };

        const COLUMN_DEFINITIONS = {
            favorite: { label: 'お気に入り', defaultVisible: true },
            checkbox: { label: '選択', defaultVisible: true },
            creator: { label: '製作者', defaultVisible: true },
            name: { label: 'デバイス名', defaultVisible: true },
            scores: { label: 'スコア (tick)', defaultVisible: true },
            speeds: { label: '速度 (OPS)', defaultVisible: true },
            cores: { label: 'コア数', defaultVisible: true },
            threads: { label: 'スレッド数', defaultVisible: true },
            bit: { label: 'データ幅', defaultVisible: true },
            volume: { label: '体積', defaultVisible: true },
            completionDate: { label: '完成日', defaultVisible: true },
            tags: { label: 'タグ', defaultVisible: true },
            actions: { label: '操作', defaultVisible: true }
        };

        const CHART_DEFINITIONS = {
            ...SCORE_DEFINITIONS,
            multiSpeed: { label: 'マルチ速度' },
            singleSpeed: { label: 'シングル速度' },
            cores: { label: 'コア数' },
            threads: { label: 'スレッド数' },
            bit: { label: 'データ幅' },
            volume: { label: '合計体積' }
        };

        const SCATTER_PLOT_AXIS_DEFINITIONS = {
            ...SCORE_DEFINITIONS,
            multiSpeed: { label: 'マルチ最大速度' },
            singleSpeed: { label: 'シングル最大速度' },
            branchSpeed: { label: 'シングル条件分岐速度' },
            cores: { label: 'コア数' },
            threads: { label: 'スレッド数' },
            bit: { label: 'データ幅' },
            volume: { label: '合計体積' }
        };

        let cpuData = [];
        let currentScoreType = 'rcbsp'; 
        let currentSpeedType = 'multi';
        let sortState = { column: 'id', order: 'asc' }; 
        let selectedCpuIds = []; 
        let isFavoriteFilterActive = false;
        let columnVisibility = {}; 
        let chartVisibility = {}; 
        let scatterPlotSettings = {};
        let scoreSettings = {};
        let comparisonChart = null; 
        let scatterPlotChart = null;
        let statisticsCharts = {};

        document.addEventListener('DOMContentLoaded', initApp);

        function initApp() {
            loadTheme(); // Load theme first to prevent flash of wrong theme
            loadTagsFromLocalStorage();
            loadScoreSettingsFromLocalStorage(); // Load score settings
            loadDataFromLocalStorage();
            loadSortStateFromLocalStorage();
            loadFavoriteFilterStateFromLocalStorage();
            loadColumnVisibilityFromLocalStorage();
            loadChartVisibilityFromLocalStorage();
            loadScatterPlotSettingsFromLocalStorage();
            renderTagFilters();
            renderNewScoreFields();
            renderSettingsModal();
            renderCPUTable();
            setupEventListeners();
            updateSelectionDependentButtons();
            updateFavoriteFilterHeaderState();
        }

        function setupEventListeners() {
            document.getElementById('cpuForm').addEventListener('submit', handleCpuFormSubmit);
            
            document.querySelectorAll('#cpuTable th[data-sort-key]').forEach(th => {
                th.addEventListener('click', () => {
                    handleSort(th.dataset.sortKey);
                });
            });

            document.getElementById('selectAllCheckbox').addEventListener('click', toggleSelectAll);
            document.querySelector('#cpuTable th.favorite-column').addEventListener('click', toggleFavoriteFilter);

            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    const activeModals = document.querySelectorAll('.modal.visible');
                    activeModals.forEach(modal => closeModal(modal.id));
                }
            });

            window.addEventListener('click', (event) => {
                if (event.target.classList.contains('modal') && event.target.classList.contains('visible')) {
                    closeModal(event.target.id);
                }
            });

            ['volumeX', 'volumeY', 'volumeZ'].forEach(id => {
                const element = document.getElementById(id);
                if(element) element.addEventListener('input', () => {
                    updateCalculatedVolumeDisplay();
                    if (document.getElementById('cpuFormModal').classList.contains('visible')) {
                         autoCheckCompactTag();
                    }
                });
            });
            
            document.querySelector('.search-box').addEventListener('input', () => filterCPUs());
            document.getElementById('import-json-input').addEventListener('change', handleImportJSON);
            
            // Scatter plot settings change listeners
            document.getElementById('scatterXAxis').addEventListener('change', (e) => { scatterPlotSettings.x = e.target.value; });
            document.getElementById('scatterYAxis').addEventListener('change', (e) => { scatterPlotSettings.y = e.target.value; });
            document.getElementById('scatterBubbleSize').addEventListener('change', (e) => { scatterPlotSettings.r = e.target.value; });
        }
        
        // --- Theme Logic ---
        function loadTheme() {
            const storedTheme = localStorage.getItem(LOCAL_STORAGE_THEME_KEY);

            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                if (!localStorage.getItem(LOCAL_STORAGE_THEME_KEY)) {
                    setTheme(e.matches ? 'dark' : 'light', false);
                    updateThemeSelectionUI();
                }
            });

            if (storedTheme) {
                setTheme(storedTheme, false);
            } else {
                setTheme(window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light', false);
            }
        }

        function setTheme(theme, save = false) {
            document.body.classList.toggle('dark-theme', theme === 'dark');
            
            if (save) {
                localStorage.setItem(LOCAL_STORAGE_THEME_KEY, theme);
            }
            
            if (document.getElementById('comparisonModal').classList.contains('visible')) {
                const cpus = selectedCpuIds.map(id => cpuData.find(c => c.id === id));
                if (cpus.length === 2 && cpus[0] && cpus[1]) renderComparisonChart(cpus[0], cpus[1]);
            }
            if (document.getElementById('scatterPlotModal').classList.contains('visible')) {
                renderScatterPlot();
            }
            if (document.getElementById('statisticsModal').classList.contains('visible')) {
                const stats = calculateStatistics();
                renderStatisticsCharts(stats);
            }
        }

        function updateThemeSelectionUI() {
            const currentTheme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
            const lightRadio = document.querySelector('input[name="theme"][value="light"]');
            const darkRadio = document.querySelector('input[name="theme"][value="dark"]');
            
            if (lightRadio && darkRadio) {
                lightRadio.checked = (currentTheme === 'light');
                darkRadio.checked = (currentTheme === 'dark');
                
                document.getElementById('lightThemeLabel').classList.toggle('checked', currentTheme === 'light');
                document.getElementById('darkThemeLabel').classList.toggle('checked', currentTheme === 'dark');
            }
        }
        
        function updateCalculatedVolumeDisplay() {
            const xInput = document.getElementById('volumeX');
            const yInput = document.getElementById('volumeY');
            const zInput = document.getElementById('volumeZ');
            const display = document.getElementById('calculatedVolumeDisplay');

            if (!xInput || !yInput || !zInput || !display) return; 

            const x = parseInt(xInput.value) || 0;
            const y = parseInt(yInput.value) || 0;
            const z = parseInt(zInput.value) || 0;
            
            const totalVolume = x * y * z;
            if (x > 0 && y > 0 && z > 0) {
                display.textContent = `合計体積: ${totalVolume.toLocaleString()} ブロック³`;
            } else {
                display.textContent = `合計体積: -`;
            }
        }

        function autoCheckCompactTag() {
            const x = parseInt(document.getElementById('volumeX').value) || 0;
            const y = parseInt(document.getElementById('volumeY').value) || 0;
            const compactTagCheckbox = document.querySelector('#tagSelectionCheckboxes input[type="checkbox"][value="64×64以下"]');

            if (compactTagCheckbox) {
                if (x > 0 && y > 0 && x <= 64 && y <= 64) {
                    compactTagCheckbox.checked = true;
                    const label = compactTagCheckbox.closest('label');
                    if (label) label.classList.add('checked');
                }
            }
        }

        function loadTagsFromLocalStorage() {
            const storedTags = localStorage.getItem(LOCAL_STORAGE_TAGS_KEY);
            if (storedTags) {
                try {
                    AVAILABLE_TAGS = JSON.parse(storedTags);
                } catch (e) {
                    console.error("Error loading tags from localStorage:", e);
                    AVAILABLE_TAGS = ["速度重視", "サイズ重視", "汎用性重視", "CPU", "GPU", "64×64以下"];
                }
            } else {
                AVAILABLE_TAGS = ["速度重視", "サイズ重視", "汎用性重視", "CPU", "GPU", "64×64以下"];
            }
        }

        function saveTagsToLocalStorage() {
            localStorage.setItem(LOCAL_STORAGE_TAGS_KEY, JSON.stringify(AVAILABLE_TAGS));
        }

        function loadDataFromLocalStorage() {
            const data = localStorage.getItem(LOCAL_STORAGE_DATA_KEY);
            try {
                const parsedData = data ? JSON.parse(data) : getDefaultCpuData();
                cpuData = parsedData.map((item, index) => {
                    const newScores = {};
                    for (const key in SCORE_DEFINITIONS) {
                        newScores[key] = (item.scores && item.scores[key] !== undefined) ? item.scores[key] : null;
                    }
                    
                    return {
                        ...item,
                        id: item.id !== undefined ? item.id : Date.now() + index,
                        isFavorite: item.isFavorite === true,
                        scores: newScores,
                        speeds: {
                            ...(item.speeds || {}),
                            branch: item.speeds && (item.speeds.branch === "" || item.speeds.branch === undefined) ? null : (item.speeds ? item.speeds.branch : null)
                        },
                        tags: Array.isArray(item.tags) ? item.tags : []
                    };
                });
            } catch (e) {
                console.error("Error loading data from localStorage:", e);
                cpuData = getDefaultCpuData();
            }
        }

        function saveDataToLocalStorage() {
            localStorage.setItem(LOCAL_STORAGE_DATA_KEY, JSON.stringify(cpuData));
        }

        function loadSortStateFromLocalStorage() {
            const storedSortState = localStorage.getItem(LOCAL_STORAGE_SORT_KEY);
            if (storedSortState) {
                try {
                    sortState = JSON.parse(storedSortState);
                } catch(e) {
                    console.error("Error loading sort state from localStorage:", e);
                    sortState = { column: 'id', order: 'asc' };
                }
            }
        }
        function saveSortStateToLocalStorage() {
            localStorage.setItem(LOCAL_STORAGE_SORT_KEY, JSON.stringify(sortState));
        }

        function loadFavoriteFilterStateFromLocalStorage() {
            const storedState = localStorage.getItem(LOCAL_STORAGE_FAVORITE_FILTER_KEY);
            isFavoriteFilterActive = storedState === 'true';
        }

        function saveFavoriteFilterStateToLocalStorage() {
            localStorage.setItem(LOCAL_STORAGE_FAVORITE_FILTER_KEY, isFavoriteFilterActive);
        }

        function loadColumnVisibilityFromLocalStorage() {
            const storedVisibility = localStorage.getItem(LOCAL_STORAGE_COLUMN_VISIBILITY_KEY);
            if (storedVisibility) {
                try {
                    columnVisibility = JSON.parse(storedVisibility);
                    for (const key in COLUMN_DEFINITIONS) {
                        if (columnVisibility[key] === undefined) {
                            columnVisibility[key] = COLUMN_DEFINITIONS[key].defaultVisible;
                        }
                    }
                } catch (e) {
                    console.error("Error loading column visibility from localStorage:", e);
                    setDefaultColumnVisibility();
                }
            } else {
                setDefaultColumnVisibility();
            }
        }

        function setDefaultColumnVisibility() {
            columnVisibility = {};
            for (const key in COLUMN_DEFINITIONS) {
                columnVisibility[key] = COLUMN_DEFINITIONS[key].defaultVisible;
            }
        }

        function saveColumnVisibilityToLocalStorage() {
            localStorage.setItem(LOCAL_STORAGE_COLUMN_VISIBILITY_KEY, JSON.stringify(columnVisibility));
        }

        function loadChartVisibilityFromLocalStorage() {
            const storedVisibility = localStorage.getItem(LOCAL_STORAGE_CHART_VISIBILITY_KEY);
            if (storedVisibility) {
                try {
                    chartVisibility = JSON.parse(storedVisibility);
                     for (const key in CHART_DEFINITIONS) {
                        if (chartVisibility[key] === undefined) {
                            chartVisibility[key] = true;
                        }
                    }
                } catch (e) {
                    console.error("Error loading chart visibility from localStorage:", e);
                    setDefaultChartVisibility();
                }
            } else {
                setDefaultChartVisibility();
            }
        }

        function setDefaultChartVisibility() {
            chartVisibility = {};
            for (const key in CHART_DEFINITIONS) {
                chartVisibility[key] = true;
            }
        }

        function saveChartVisibilityToLocalStorage() {
            localStorage.setItem(LOCAL_STORAGE_CHART_VISIBILITY_KEY, JSON.stringify(chartVisibility));
        }

        function loadScatterPlotSettingsFromLocalStorage() {
            const storedSettings = localStorage.getItem(LOCAL_STORAGE_SCATTER_KEY);
            if (storedSettings) {
                try {
                    scatterPlotSettings = JSON.parse(storedSettings);
                } catch (e) {
                    console.error("Error loading scatter plot settings from localStorage:", e);
                    setDefaultScatterPlotSettings();
                }
            } else {
                setDefaultScatterPlotSettings();
            }
        }

        function setDefaultScatterPlotSettings() {
            scatterPlotSettings = {
                x: 'volume',
                y: 'multiSpeed',
                r: 'cores'
            };
        }

        function saveScatterPlotSettingsToLocalStorage() {
            localStorage.setItem(LOCAL_STORAGE_SCATTER_KEY, JSON.stringify(scatterPlotSettings));
        }

        // --- NEW: Score Settings ---
        function loadScoreSettingsFromLocalStorage() {
            const storedSettings = localStorage.getItem(LOCAL_STORAGE_SCORE_SETTINGS_KEY);
            const defaultSettings = {
                rcbsp: { highIsBetter: false, highThreshold: 100, mediumThreshold: 200 },
                rcbfa: { highIsBetter: false, highThreshold: 500, mediumThreshold: 1000 },
                rcbmp: { highIsBetter: false, highThreshold: 200, mediumThreshold: 400 },
                rcbwm: { highIsBetter: false, highThreshold: 100, mediumThreshold: 200 },
                rcbrm: { highIsBetter: false, highThreshold: 100, mediumThreshold: 200 },
                rcbml: { highIsBetter: false, highThreshold: 100, mediumThreshold: 200 },
                rcbdv: { highIsBetter: false, highThreshold: 200, mediumThreshold: 400 },
                rcbsq: { highIsBetter: false, highThreshold: 500, mediumThreshold: 1000 },
                rcbsh: { highIsBetter: false, highThreshold: 50, mediumThreshold: 100 },
            };
            if (storedSettings) {
                try {
                    scoreSettings = JSON.parse(storedSettings);
                    // Ensure all keys exist
                    for (const key in defaultSettings) {
                        if (!scoreSettings[key]) {
                            scoreSettings[key] = defaultSettings[key];
                        }
                    }
                } catch (e) {
                    console.error("Error loading score settings from localStorage:", e);
                    scoreSettings = defaultSettings;
                }
            } else {
                scoreSettings = defaultSettings;
            }
        }

        function saveScoreSettingsToLocalStorage() {
            localStorage.setItem(LOCAL_STORAGE_SCORE_SETTINGS_KEY, JSON.stringify(scoreSettings));
        }
        // --- END: Score Settings ---

        function applyColumnVisibility() {
            const table = document.getElementById('cpuTable');
            if (!table) return;

            const headers = table.querySelectorAll('thead th');
            headers.forEach(th => {
                const key = th.dataset.columnKey;
                if (key) {
                    th.style.display = columnVisibility[key] ? '' : 'none';
                }
            });

            const rows = table.querySelectorAll('tbody tr');
            const columnKeysOrder = Array.from(headers).map(th => th.dataset.columnKey);

            rows.forEach(row => {
                if (row.classList.contains('no-data')) return;
                const cells = row.querySelectorAll('td');
                cells.forEach((cell, index) => {
                    const key = columnKeysOrder[index];
                    if (key) {
                        cell.style.display = columnVisibility[key] ? '' : 'none';
                    }
                });
            });
            updateTableColspan();
        }
        
        function updateTableColspan() {
            const noDataRow = document.querySelector('#cpuTableBody tr.no-data');
            if (noDataRow) {
                const visibleColumnCount = Object.values(columnVisibility).filter(visible => visible).length;
                const noDataCell = noDataRow.querySelector('td');
                if (noDataCell) {
                    noDataCell.colSpan = Math.max(1, visibleColumnCount);
                }
            }
        }


        function getDefaultCpuData() {
            return [
                { id: 1, creator: "水地", name: "NX RED V1 CPU", scores: { rcbsp: 100, rcbfa: 500, rcbmp: 200, rcbwm: 150, rcbrm: 160, rcbml: 120, rcbdv: 300, rcbsq: 600, rcbsh: 80 }, speeds: { multi: 5200000, single: 4200000, branch: 3800000 }, microarchitecture: "カスタム64bit", description: "高性能ゲーミング向けCPU。", minecraftEdition: "Java", bit: 64, threads: 16, cores: 8, volume: { x: 10, y: 10, z: 5 }, completionDate: "2023-10-20", tags: ["速度重視", "CPU"], isFavorite: false },
                { id: 2, creator: "テックマスター", name: "Quantum Core X9 CPU", scores: { rcbsp: 80, rcbfa: 400, rcbmp: 150, rcbwm: 100, rcbrm: 110, rcbml: 90, rcbdv: 250, rcbsq: 500, rcbsh: 60 }, speeds: { multi: 6000000, single: 5500000, branch: null }, microarchitecture: "Quantum-RISC", description: "次世代量子計算技術応用。", minecraftEdition: "Bedrock", bit: 64, threads: 32, cores: 16, volume: { x: 20, y: 15, z: 10 }, completionDate: "2024-01-15", tags: ["速度重視", "汎用性重視", "CPU"], isFavorite: true },
                { id: 3, creator: "CPUクリエイター", name: "ThunderBolt Pro CPU", scores: { rcbsp: 120, rcbfa: 600, rcbmp: 250, rcbwm: 200, rcbrm: 210, rcbml: 150, rcbdv: 350, rcbsq: 700, rcbsh: 100 }, speeds: { multi: 4800000, single: 3900000, branch: 4200000 }, microarchitecture: "ARM-V9カスタム", description: "省電力と高性能を両立。", minecraftEdition: "Java", bit: 32, threads: 24, cores: 12, volume: { x: 8, y: 8, z: 8 }, completionDate: "2023-05-01", tags: ["汎用性重視", "CPU", "64×64以下"], isFavorite: false },
                { id: 4, creator: "新人", name: "MyFirstCPU", scores: { rcbsp: 1000, rcbfa: 5000, rcbmp: 2000, rcbwm: null, rcbrm: null, rcbml: null, rcbdv: null, rcbsq: null, rcbsh: null }, speeds: { multi: 10, single: 5, branch: null }, microarchitecture: "Simple ALU", description: "初めて作ったCPUです！", minecraftEdition: "Java", bit: 8, threads: 1, cores: 1, volume: { x: 5, y: 5, z: 5 }, completionDate: "2024-03-01", tags: ["サイズ重視", "CPU", "64×64以下"], isFavorite: false },
                { id: 5, creator: "GPUマニア", name: "PixelBlaster 3000 GPU", scores: { rcbsp: null, rcbfa: null, rcbmp: null, rcbwm: null, rcbrm: null, rcbml: null, rcbdv: null, rcbsq: null, rcbsh: null }, speeds: { multi: 150000, single: 12000, branch: null }, microarchitecture: "Rasterizer Core v2", description: "超高速描画GPU。ただしCPU機能はなし。", minecraftEdition: "Java", bit: 128, threads: 1024, cores: 256, volume: { x: 15, y: 5, z: 20 }, completionDate: "2024-02-20", tags: ["速度重視", "GPU"], isFavorite: true }
            ];
        }
        
        function getTagClass(tagName) {
            switch (tagName) {
                case "速度重視": return "tag-speed";
                case "サイズ重視": return "tag-size";
                case "汎用性重視": return "tag-versatile";
                case "CPU": return "tag-cpu-tag";
                case "GPU": return "tag-gpu";
                case "64×64以下": return "tag-compact";
                default: return "";
            }
        }

        function renderCPUTable() {
            const tbody = document.getElementById('cpuTableBody');
            tbody.innerHTML = '';

            const dataToRender = sortCPUData([...cpuData]); 

            if (dataToRender.length === 0) {
                tbody.innerHTML = `<tr class="no-data"><td><i class="fas fa-info-circle"></i> データがありません。最初のデバイスを追加してみましょう！</td></tr>`;
                updateSortIndicators();
                applyColumnVisibility(); 
                filterCPUs(); 
                return;
            }

            dataToRender.forEach(cpu => {
                const row = document.createElement('tr');
                row.dataset.cpuId = cpu.id; 
                const calculatedVolume = cpu.volume.x * cpu.volume.y * cpu.volume.z;
                
                let displaySpeedValue;
                let currentSpeed = cpu.speeds[currentSpeedType];

                if (currentSpeedType === 'branch' && (currentSpeed === null || currentSpeed === undefined)) {
                    displaySpeedValue = '未測定';
                } else {
                    displaySpeedValue = (currentSpeed !== null && currentSpeed !== undefined) ? currentSpeed.toLocaleString() : 'N/A';
                }
                const speedUnitDisplay = (currentSpeedType === 'branch' && (currentSpeed === null || currentSpeed === undefined)) ? '' : ` ${getSpeedUnit(currentSpeedType)}`;

                let currentScoreValue = cpu.scores[currentScoreType];
                let displayScoreValue;
                let scoreCssClass = '';

                if (currentScoreValue === null || currentScoreValue === undefined) {
                    displayScoreValue = '未測定';
                } else {
                    displayScoreValue = currentScoreValue.toLocaleString();
                    scoreCssClass = getScoreClass(currentScoreValue, currentScoreType);
                }

                const tagsHtml = cpu.tags && cpu.tags.length > 0 
                    ? cpu.tags.map(tag => `<span class="tag-badge ${getTagClass(tag)}">${tag}</span>`).join('') 
                    : 'タグなし';

                const isChecked = selectedCpuIds.includes(cpu.id);
                const favoriteIconClass = cpu.isFavorite ? 'fas fa-star is-favorite' : 'far fa-star';


                row.innerHTML = `
                    <td data-column-key="favorite" class="favorite-cell">
                        <i class="favorite-toggle ${favoriteIconClass}" onclick="toggleFavorite(${cpu.id}, event)"></i>
                    </td>
                    <td data-column-key="checkbox" class="checkbox-cell">
                        <input type="checkbox" class="cpu-checkbox" data-cpu-id="${cpu.id}" onchange="handleCheckboxChange(this)" ${isChecked ? 'checked' : ''}>
                    </td>
                    <td data-column-key="creator" class="creator-name">${cpu.creator}</td>
                    <td data-column-key="name" class="cpu-name">${cpu.name}</td>
                    <td data-column-key="scores" class="score-cell" onclick="cycleScoreTypeAndUpdate(${cpu.id})">
                        <div class="metric-value ${scoreCssClass}">${displayScoreValue}</div>
                        <div class="metric-label">${currentScoreType.toUpperCase()}<i class="fas fa-sync-alt"></i></div>
                    </td>
                    <td data-column-key="speeds" class="speed-cell" onclick="cycleSpeedTypeAndUpdate(${cpu.id})">
                        <div class="metric-value">${displaySpeedValue}${speedUnitDisplay}</div>
                        <div class="metric-label">${getSpeedLabel(currentSpeedType)}<i class="fas fa-sync-alt"></i></div>
                    </td>
                    <td data-column-key="cores">${cpu.cores}</td>
                    <td data-column-key="threads">${cpu.threads}</td>
                    <td data-column-key="bit">${cpu.bit}-bit</td>
                    <td data-column-key="volume">${calculatedVolume.toLocaleString()}</td>
                    <td data-column-key="completionDate">${cpu.completionDate}</td>
                    <td data-column-key="tags" class="tags-cell">${tagsHtml}</td>
                    <td data-column-key="actions">
                        <button class="action-btn details-btn" onclick="showCPUDetails(${cpu.id})"><i class="fas fa-eye"></i> 詳細</button>
                        <button class="action-btn edit-btn" onclick="openCpuFormModal(${cpu.id})"><i class="fas fa-edit"></i> 編集</button>
                    </td>
                `;
                tbody.appendChild(row);
            });
            updateSortIndicators();
            applyColumnVisibility(); 
            filterCPUs(); 
            updateSelectAllCheckboxState();
        }
        
        function getScoreClass(score, scoreType) {
            if (score === null || score === undefined) return '';
            const settings = scoreSettings[scoreType.toLowerCase()];
            if (!settings) return '';

            const { highIsBetter, highThreshold, mediumThreshold } = settings;

            if (highIsBetter) {
                if (score >= highThreshold) return 'high-score';
                if (score >= mediumThreshold) return 'medium-score';
            } else { // Lower is better
                if (score <= highThreshold) return 'high-score';
                if (score <= mediumThreshold) return 'medium-score';
            }
            return 'low-score';
        }

        function getSpeedUnit(type) {
            return 'OPS'; 
        }

        function getSpeedLabel(type) {
            const labels = { multi: 'マルチ最大', single: 'シングル最大', branch: 'シングル条件分岐' };
            return labels[type];
        }

        function cycleScoreTypeAndUpdate(cpuId) {
            const types = Object.keys(SCORE_DEFINITIONS);
            currentScoreType = types[(types.indexOf(currentScoreType) + 1) % types.length];
            renderCPUTable(); 
        }

        function cycleSpeedTypeAndUpdate(cpuId) {
            const types = ['multi', 'single', 'branch'];
            currentSpeedType = types[(types.indexOf(currentSpeedType) + 1) % types.length];
            renderCPUTable(); 
        }
        
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                document.body.style.overflow = 'hidden';
                modal.style.display = 'block';
                requestAnimationFrame(() => { 
                    modal.classList.add('visible');
                });
            }
        }

        function showCPUDetails(cpuId) {
            const cpu = cpuData.find(c => c.id === cpuId);
            if (!cpu) return;

            document.getElementById('detailTitle').textContent = `${cpu.name} - 詳細情報`;
            const calculatedVolume = cpu.volume.x * cpu.volume.y * cpu.volume.z;
            const branchSpeedDisplay = (cpu.speeds.branch === null || cpu.speeds.branch === undefined) ? "未測定" : `${cpu.speeds.branch.toLocaleString()} ${getSpeedUnit('branch')}`;
            
            let scoreDetailsHtml = '';
            for (const key in cpu.scores) {
                const scoreValue = cpu.scores[key];
                const displayValue = (scoreValue === null || scoreValue === undefined) ? "未測定" : scoreValue.toLocaleString();
                const scoreClass = getScoreClass(scoreValue, key);
                scoreDetailsHtml += `<div class="detail-item"><span class="detail-label">${key.toUpperCase()}:</span><span class="detail-value ${scoreClass}">${displayValue} tick</span></div>`;
            }

            const tagsHtml = cpu.tags && cpu.tags.length > 0 
                ? cpu.tags.map(tag => `<span class="tag-badge ${getTagClass(tag)}">${tag}</span>`).join('') 
                : "タグなし";
            
            const favoriteStar = cpu.isFavorite ? `<i class="fas fa-star" style="color: #ffc777; margin-left: 10px;"></i>` : '';


            document.getElementById('detailContent').innerHTML = `
                <div style="margin-bottom: 25px; font-size: 1.2em;"><strong>${cpu.name}</strong> ${favoriteStar}</div>
                <div class="cpu-detail-grid-main">
                    <div class="detail-section">
                        <h3><i class="fas fa-trophy"></i> パフォーマンススコア</h3>
                        ${scoreDetailsHtml}
                        <div class="detail-item"><span class="detail-label">マルチ最大:</span><span class="detail-value">${cpu.speeds.multi.toLocaleString()} ${getSpeedUnit('multi')}</span></div>
                        <div class="detail-item"><span class="detail-label">シングル最大:</span><span class="detail-value">${cpu.speeds.single.toLocaleString()} ${getSpeedUnit('single')}</span></div>
                        <div class="detail-item"><span class="detail-label">シングル条件分岐:</span><span class="detail-value">${branchSpeedDisplay}</span></div>
                    </div>
                    <div class="detail-section">
                        <h3><i class="fas fa-tools"></i> 基本仕様</h3>
                        <div class="detail-item"><span class="detail-label">製作者:</span><span class="detail-value">${cpu.creator}</span></div>
                        <div class="detail-item"><span class="detail-label">マイクロアーキテクチャ:</span><span class="detail-value">${cpu.microarchitecture || "N/A"}</span></div>
                        <div class="detail-item"><span class="detail-label">コア/ユニット数:</span><span class="detail-value">${cpu.cores}</span></div>
                        <div class="detail-item"><span class="detail-label">スレッド/並列処理単位:</span><span class="detail-value">${cpu.threads}</span></div>
                        <div class="detail-item"><span class="detail-label">マイクラEdition:</span><span class="detail-value">${cpu.minecraftEdition}</span></div>
                        <div class="detail-item"><span class="detail-label">データ幅:</span><span class="detail-value">${cpu.bit}-bit</span></div>
                        <div class="detail-item"><span class="detail-label">体積 (X×Y×Z):</span><span class="detail-value">${cpu.volume.x}×${cpu.volume.y}×${cpu.volume.z} = ${calculatedVolume.toLocaleString()} ブロック³</span></div>
                        <div class="detail-item"><span class="detail-label">完成日:</span><span class="detail-value">${cpu.completionDate}</span></div>
                    </div>
                </div>
                <div class="cpu-detail-grid-sub">
                     <div class="detail-section">
                        <h3><i class="fas fa-tags"></i> タグ</h3>
                        <div class="detail-tags-container">${tagsHtml}</div>
                    </div>
                    <div class="detail-section">
                        <h3><i class="fas fa-file-alt"></i> 説明</h3>
                        <p style="line-height: 1.7;">${cpu.description ? cpu.description.replace(/\n/g, '<br>') : "記載なし"}</p>
                    </div>
                </div>
            `;
            openModal('detailModal');
        }

        function renderNewScoreFields() {
            const container = document.getElementById('newScoreFieldsContainer');
            container.innerHTML = '';
            for (const key in SCORE_DEFINITIONS) {
                const score = SCORE_DEFINITIONS[key];
                const fieldHtml = `
                    <div class="form-group">
                        <label for="${key}Score">${score.label}</label>
                        <input type="number" id="${key}Score" min="0" placeholder="未入力可">
                        <div class="invalid-feedback">${score.label}は0以上の数値で入力してください。</div>
                    </div>
                `;
                container.innerHTML += fieldHtml;
            }
        }

        function renderTagSelectionCheckboxes(containerId, selectedTags = []) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            AVAILABLE_TAGS.forEach(tag => {
                const checkboxId = `tag-checkbox-${tag.replace(/\s|×/g, '-')}-${containerId}`; 
                const label = document.createElement('label');
                label.htmlFor = checkboxId;
                label.className = getTagClass(tag);
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = checkboxId;
                checkbox.value = tag;
                checkbox.checked = selectedTags.includes(tag);
                
                const span = document.createElement('span');
                span.textContent = tag;
                
                label.appendChild(checkbox);
                label.appendChild(span);
                container.appendChild(label);

                if (checkbox.checked) {
                    label.classList.add('checked');
                }
                checkbox.addEventListener('change', () => {
                    label.classList.toggle('checked', checkbox.checked);
                });
            });
        }
        
        function openCpuFormModal(cpuId) {
            const form = document.getElementById('cpuForm');
            form.reset();
            clearFormValidation(form);
            updateCalculatedVolumeDisplay(); 
            
            const modalTitle = document.getElementById('cpuFormTitle');
            const submitBtn = document.getElementById('cpuFormSubmitBtn');
            document.getElementById('editingCpuId').value = cpuId || '';

            let currentTags = [];
            if (cpuId) { 
                const cpu = cpuData.find(c => c.id === cpuId);
                if (!cpu) return;
                modalTitle.textContent = 'デバイス情報を編集';
                submitBtn.innerHTML = '<i class="fas fa-save"></i> 変更を保存';

                document.getElementById('creator').value = cpu.creator;
                document.getElementById('cpuName').value = cpu.name;
                
                for (const key in cpu.scores) {
                    const input = document.getElementById(`${key}Score`);
                    if (input) {
                        input.value = (cpu.scores[key] === null || cpu.scores[key] === undefined) ? '' : cpu.scores[key];
                    }
                }
                
                document.getElementById('multiSpeed').value = cpu.speeds.multi;
                document.getElementById('singleSpeed').value = cpu.speeds.single;
                document.getElementById('branchSpeed').value = (cpu.speeds.branch === null || cpu.speeds.branch === undefined) ? '' : cpu.speeds.branch;
                document.getElementById('microarchitecture').value = cpu.microarchitecture || ''; 
                document.getElementById('cores').value = cpu.cores;
                document.getElementById('threads').value = cpu.threads;
                document.getElementById('minecraftEdition').value = cpu.minecraftEdition;
                document.getElementById('bit').value = cpu.bit;
                document.getElementById('volumeX').value = cpu.volume.x;
                document.getElementById('volumeY').value = cpu.volume.y;
                document.getElementById('volumeZ').value = cpu.volume.z;
                document.getElementById('completionDate').value = cpu.completionDate;
                document.getElementById('description').value = cpu.description || '';
                currentTags = cpu.tags || [];
                updateCalculatedVolumeDisplay(); 
            } else { 
                modalTitle.textContent = '新しいデバイスを追加';
                submitBtn.innerHTML = '<i class="fas fa-plus-circle"></i> デバイスを追加';
                autoCheckCompactTag(); 
            }
            renderTagSelectionCheckboxes('tagSelectionCheckboxes', currentTags);
            openModal('cpuFormModal');
        }
        
        function handleCpuFormSubmit(e) {
            e.preventDefault();
            const form = e.target;
            if (!validateForm(form)) {
                showNotification('入力内容にエラーがあります。確認してください。', 'error');
                return;
            }

            const editingIdStr = document.getElementById('editingCpuId').value;
            const editingId = editingIdStr ? parseInt(editingIdStr) : null;
            
            const branchSpeedInput = document.getElementById('branchSpeed').value.trim();
            
            const newScores = {};
            for (const key in SCORE_DEFINITIONS) {
                const input = document.getElementById(`${key}Score`).value.trim();
                newScores[key] = input === '' ? null : parseInt(input);
            }

            const selectedTags = [];
            document.querySelectorAll('#tagSelectionCheckboxes input[type="checkbox"]:checked').forEach(cb => {
                selectedTags.push(cb.value);
            });
            
            const cpuEntry = {
                creator: document.getElementById('creator').value.trim(),
                name: document.getElementById('cpuName').value.trim(),
                scores: newScores,
                speeds: {
                    multi: parseFloat(document.getElementById('multiSpeed').value),
                    single: parseFloat(document.getElementById('singleSpeed').value),
                    branch: branchSpeedInput === '' ? null : parseFloat(branchSpeedInput)
                },
                microarchitecture: document.getElementById('microarchitecture').value.trim(), 
                description: document.getElementById('description').value.trim(),
                cores: parseInt(document.getElementById('cores').value),
                threads: parseInt(document.getElementById('threads').value),
                minecraftEdition: document.getElementById('minecraftEdition').value,
                bit: parseInt(document.getElementById('bit').value),
                volume: {
                    x: parseInt(document.getElementById('volumeX').value),
                    y: parseInt(document.getElementById('volumeY').value),
                    z: parseInt(document.getElementById('volumeZ').value)
                },
                completionDate: document.getElementById('completionDate').value,
                tags: selectedTags
            };

            if (editingId !== null) { 
                const index = cpuData.findIndex(c => c.id === editingId);
                if (index > -1) {
                    cpuEntry.isFavorite = cpuData[index].isFavorite;
                    cpuData[index] = { ...cpuData[index], ...cpuEntry, id: editingId }; 
                    showNotification('<i class="fas fa-check-circle"></i> デバイス情報が更新されました！', 'success');
                } else {
                    showNotification('<i class="fas fa-exclamation-circle"></i> 更新対象のデバイスが見つかりません。', 'error');
                    return;
                }
            } else { 
                cpuEntry.id = cpuData.length > 0 ? Math.max(0, ...cpuData.map(c => c.id)) + 1 : 1;
                while(cpuData.some(c => c.id === cpuEntry.id)) {
                    cpuEntry.id++;
                }
                cpuEntry.isFavorite = false;
                cpuData.push(cpuEntry);
                showNotification('<i class="fas fa-plus-circle"></i> 新しいデバイスが追加されました！', 'success');
            }
            
            saveDataToLocalStorage();
            renderCPUTable(); 
            closeModal('cpuFormModal');
        }

        function validateForm(form) {
            let isValid = true;
            clearFormValidation(form);

            const requiredInputs = form.querySelectorAll('[required]');
            
            requiredInputs.forEach(input => {
                let hasError = false;
                if (input.type === 'text' || input.tagName.toLowerCase() === 'select') {
                    if (!input.value.trim()) hasError = true;
                } else if (input.type === 'number') {
                    const val = parseFloat(input.value);
                    const min = parseFloat(input.min);
                    if (input.value.trim() === '' || isNaN(val) || (input.min !== undefined && !isNaN(min) && val < min)) {
                         hasError = true;
                    }
                } else if (input.type === 'date') {
                     if (!input.value) hasError = true;
                }
                if(hasError){
                    isValid = false;
                    input.classList.add('is-invalid');
                }
            });

            const optionalNumberFields = [ { id: 'branchSpeed', min: 0 } ];
            for (const key in SCORE_DEFINITIONS) {
                optionalNumberFields.push({ id: `${key}Score`, min: 0 });
            }

            optionalNumberFields.forEach(field => {
                const input = form.querySelector(`#${field.id}`);
                if (input && input.value.trim() !== '') {
                    const val = parseFloat(input.value);
                    const minVal = parseFloat(field.min);
                    if (isNaN(val) || (field.min !== undefined && !isNaN(minVal) && val < minVal)) {
                        isValid = false;
                        input.classList.add('is-invalid');
                    }
                }
            });
            return isValid;
        }

        function clearFormValidation(form) {
            form.querySelectorAll('.is-invalid').forEach(el => el.classList.remove('is-invalid'));
        }

        function deleteSelectedCPUs() {
            if (selectedCpuIds.length === 0) {
                showNotification('削除するデバイスが選択されていません。', 'info');
                return;
            }

            if (confirm(`選択された ${selectedCpuIds.length} 個のデバイスを本当に削除しますか？この操作は元に戻せません。`)) {
                const deletedCount = selectedCpuIds.length;
                cpuData = cpuData.filter(cpu => !selectedCpuIds.includes(cpu.id));
                selectedCpuIds = [];

                saveDataToLocalStorage();
                renderCPUTable();
                updateSelectionDependentButtons();
                showNotification(`<i class="fas fa-trash-alt"></i> ${deletedCount} 個のデバイスが削除されました。`, 'info');
            }
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal && modal.classList.contains('visible')) {
                document.body.style.overflow = '';
                if (modalId === 'comparisonModal' && comparisonChart) {
                    comparisonChart.destroy();
                    comparisonChart = null;
                }
                if (modalId === 'scatterPlotModal' && scatterPlotChart) {
                    scatterPlotChart.destroy();
                    scatterPlotChart = null;
                }
                if (modalId === 'statisticsModal') {
                    for (const chartId in statisticsCharts) {
                        if (statisticsCharts[chartId]) {
                            statisticsCharts[chartId].destroy();
                        }
                    }
                    statisticsCharts = {};
                }
                modal.classList.add('closing'); 
                modal.classList.remove('visible');
                setTimeout(() => {
                    modal.style.display = 'none';
                    modal.classList.remove('closing');
                }, 300); 
            }
        }
        
        function renderTagFilters() {
            const container = document.getElementById('tagFiltersContainer');
            container.innerHTML = '';
            AVAILABLE_TAGS.forEach(tag => {
                const checkboxId = `filter-tag-${tag.replace(/\s|×/g, '-')}`;
                const label = document.createElement('label');
                label.htmlFor = checkboxId;
                label.className = getTagClass(tag);
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = checkboxId;
                checkbox.value = tag;
                checkbox.addEventListener('change', () => {
                    label.classList.toggle('checked', checkbox.checked);
                    filterCPUs();
                });
                
                const span = document.createElement('span');
                span.textContent = tag;
                
                label.appendChild(checkbox);
                label.appendChild(span);
                container.appendChild(label);
            });
        }

        function getSelectedFilterTags() {
            const selectedTags = [];
            document.querySelectorAll('#tagFiltersContainer input[type="checkbox"]:checked').forEach(cb => {
                selectedTags.push(cb.value);
            });
            return selectedTags;
        }

        function filterCPUs() {
            const searchTerm = document.querySelector('.search-box').value.toLowerCase().trim();
            const selectedFilterTags = getSelectedFilterTags();
            const rows = document.querySelectorAll('#cpuTableBody tr');
            let foundVisible = false;

            rows.forEach(row => {
                if (row.classList.contains('no-data')) return; 

                const cpuId = parseInt(row.dataset.cpuId);
                const cpu = cpuData.find(c => c.id === cpuId);
                if (!cpu) { 
                    row.style.display = 'none';
                    return;
                }

                const textContent = row.textContent.toLowerCase();
                const matchesText = searchTerm === '' || textContent.includes(searchTerm);

                let matchesTags = true; 
                if (selectedFilterTags.length > 0) {
                    if (cpu.tags && cpu.tags.length > 0) {
                        matchesTags = selectedFilterTags.every(filterTag => cpu.tags.includes(filterTag));
                    } else {
                        matchesTags = false; 
                    }
                }
                
                const matchesFavorite = !isFavoriteFilterActive || (isFavoriteFilterActive && cpu.isFavorite);

                const display = matchesText && matchesTags && matchesFavorite ? '' : 'none';
                row.style.display = display;
                if (display === '') foundVisible = true;
            });

            const noDataRow = document.querySelector('#cpuTableBody tr.no-data');
            if (noDataRow) { 
                if (cpuData.length > 0) {
                    if (!foundVisible) {
                        let message = '<i class="fas fa-search-minus"></i> ';
                        let conditions = [];
                        if(searchTerm) conditions.push(`「${searchTerm}」に一致`);
                        if(selectedFilterTags.length > 0) conditions.push("選択されたタグをすべて持つ");
                        if(isFavoriteFilterActive) conditions.push("お気に入り登録されている");
                        
                        if (conditions.length > 0) {
                             message += conditions.join("、かつ ") + "デバイスは見つかりませんでした。";
                        } else {
                             message += `表示できるデバイスがありません。`;
                        }
                        noDataRow.innerHTML = `<td>${message}</td>`;
                        noDataRow.style.display = '';
                    } else {
                        noDataRow.style.display = 'none';
                    }
                } else { 
                    noDataRow.innerHTML = `<td><i class="fas fa-info-circle"></i> データがありません。最初のデバイスを追加してみましょう！</td>`;
                    noDataRow.style.display = '';
                }
            }
            updateTableColspan(); 
            updateSelectAllCheckboxState();
        }


        function sortCPUData(data) {
            if (!sortState.column || sortState.order === 'none') {
                return data.sort((a, b) => (a.id || 0) - (b.id || 0)); 
            }

            return data.sort((a, b) => {
                let valA, valB;

                switch (sortState.column) {
                    case 'creator': case 'name': case 'minecraftEdition':
                        valA = String(a[sortState.column] || '').toLowerCase();
                        valB = String(b[sortState.column] || '').toLowerCase();
                        break;
                    case 'microarchitecture': 
                        valA = String(a.microarchitecture || '').toLowerCase();
                        valB = String(b.microarchitecture || '').toLowerCase();
                        break;
                    case 'scores':
                        valA = a.scores[currentScoreType];
                        valB = b.scores[currentScoreType];
                        valA = (valA === null || valA === undefined) ? Number.MIN_SAFE_INTEGER : valA; 
                        valB = (valB === null || valB === undefined) ? Number.MIN_SAFE_INTEGER : valB;
                        break;
                    case 'speeds':
                        valA = a.speeds[currentSpeedType];
                        valB = b.speeds[currentSpeedType];
                        if (currentSpeedType === 'branch') { 
                            valA = (valA === null || valA === undefined) ? Number.MIN_SAFE_INTEGER : valA; 
                            valB = (valB === null || valB === undefined) ? Number.MIN_SAFE_INTEGER : valB;
                        }
                        break;
                    case 'cores': case 'threads': case 'bit':
                        valA = parseFloat(a[sortState.column] || 0);
                        valB = parseFloat(b[sortState.column] || 0);
                        break;
                    case 'volume':
                        valA = (a.volume.x || 0) * (a.volume.y || 0) * (a.volume.z || 0);
                        valB = (b.volume.x || 0) * (b.volume.y || 0) * (b.volume.z || 0);
                        break;
                    case 'completionDate': 
                        valA = new Date(a.completionDate || 0);
                        valB = new Date(b.completionDate || 0);
                        break;
                    default: return 0;
                }

                let comparison = 0;
                if (valA < valB) comparison = -1;
                if (valA > valB) comparison = 1;
                
                return sortState.order === 'asc' ? comparison : comparison * -1;
            });
        }
        
        function handleSort(columnKey) {
            if (sortState.column === columnKey) {
                if (sortState.order === 'asc') sortState.order = 'desc';
                else if (sortState.order === 'desc') sortState.order = 'none'; 
                else sortState.order = 'asc'; 
            } else {
                sortState.column = columnKey;
                sortState.order = 'asc';
            }
            saveSortStateToLocalStorage();
            renderCPUTable();
        }

        function updateSortIndicators() {
            document.querySelectorAll('#cpuTable th[data-sort-key]').forEach(th => {
                const key = th.dataset.sortKey;
                const indicator = th.querySelector('.sort-indicator');
                if (indicator) {
                    if (sortState.column === key && sortState.order !== 'none') {
                        indicator.innerHTML = sortState.order === 'asc' ? '<i class="fas fa-sort-up"></i>' : '<i class="fas fa-sort-down"></i>';
                    } else if (sortState.column === key && sortState.order === 'none') {
                         indicator.innerHTML = '<i class="fas fa-sort" style="opacity:0.5;"></i>';
                    }
                     else {
                        indicator.innerHTML = '<i class="fas fa-sort" style="opacity:0.5;"></i>'; 
                    }
                }
            });
        }

        function showNotification(message, type = 'info', duration = 3500) { 
            const notification = document.getElementById('notification');
            notification.innerHTML = message; 
            
            notification.className = 'notification'; 
            notification.classList.add(type); 

            requestAnimationFrame(() => {
                notification.classList.add('visible');
            });
            
            if (notification.timeoutId) clearTimeout(notification.timeoutId);

            notification.timeoutId = setTimeout(() => {
                notification.classList.remove('visible');
            }, duration);
        }

        function toggleFavorite(cpuId, event) {
            event.stopPropagation();
            const cpu = cpuData.find(c => c.id === cpuId);
            if (cpu) {
                cpu.isFavorite = !cpu.isFavorite;
                saveDataToLocalStorage();
                renderCPUTable(); 
                showNotification(cpu.isFavorite ? `<i class="fas fa-star"></i> 「${cpu.name}」をお気に入りに追加しました。` : `<i class="far fa-star"></i> 「${cpu.name}」をお気に入りから解除しました。`, 'info', 2000);
            }
        }

        function toggleFavoriteFilter() {
            isFavoriteFilterActive = !isFavoriteFilterActive;
            saveFavoriteFilterStateToLocalStorage();
            updateFavoriteFilterHeaderState();
            filterCPUs();
        }

        function updateFavoriteFilterHeaderState() {
            const th = document.querySelector('#cpuTable th.favorite-column');
            if (th) {
                th.classList.toggle('active', isFavoriteFilterActive);
            }
        }

        function handleCheckboxChange(checkboxElement) {
            const cpuId = parseInt(checkboxElement.dataset.cpuId);
            if (checkboxElement.checked) {
                if (!selectedCpuIds.includes(cpuId)) {
                    selectedCpuIds.push(cpuId);
                }
            } else {
                selectedCpuIds = selectedCpuIds.filter(id => id !== cpuId);
            }
            updateSelectionDependentButtons();
            updateSelectAllCheckboxState();
        }

        function toggleSelectAll(event) {
            const isChecked = event.target.checked;
            const visibleCheckboxes = document.querySelectorAll('.cpu-checkbox:not([style*="display: none"])');
            const visibleCpuIds = Array.from(visibleCheckboxes).map(cb => parseInt(cb.closest('tr').dataset.cpuId));

            if (isChecked) {
                // Add only visible CPUs to selection
                visibleCpuIds.forEach(id => {
                    if (!selectedCpuIds.includes(id)) {
                        selectedCpuIds.push(id);
                    }
                });
            } else {
                // Remove visible CPUs from selection
                selectedCpuIds = selectedCpuIds.filter(id => !visibleCpuIds.includes(id));
            }
            
            document.querySelectorAll('.cpu-checkbox').forEach(cb => {
                const row = cb.closest('tr');
                if (row.style.display !== 'none') {
                    cb.checked = isChecked;
                }
            });

            updateSelectionDependentButtons();
        }

        function updateSelectAllCheckboxState() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            if (!selectAllCheckbox) return;

            const visibleCheckboxes = Array.from(document.querySelectorAll('.cpu-checkbox')).filter(cb => cb.closest('tr').style.display !== 'none');
            const visibleAndCheckedCount = visibleCheckboxes.filter(cb => cb.checked).length;
            
            if (visibleCheckboxes.length === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else if (visibleAndCheckedCount === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else if (visibleAndCheckedCount === visibleCheckboxes.length) {
                selectAllCheckbox.checked = true;
                selectAllCheckbox.indeterminate = false;
            } else {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = true;
            }
        }


        function updateSelectionDependentButtons() {
            const selectedCount = selectedCpuIds.length;
            
            // Update counts on buttons
            document.querySelectorAll('.selected-count').forEach(span => {
                span.textContent = selectedCount;
            });

            // Enable/disable compare button
            const compareBtn = document.getElementById('compareSelectedBtn');
            if (compareBtn) {
                compareBtn.disabled = selectedCount !== 2;
            }

            // Enable/disable delete button
            const deleteBtn = document.getElementById('deleteSelectedBtn');
            if (deleteBtn) {
                deleteBtn.disabled = selectedCount === 0;
            }
        }

        function formatValueForComparison(value, unit = '', isScore = false, scoreType = '') {
            if (value === null || value === undefined) return '<span class="comparison-na">未測定</span>';
            let displayValue = value.toLocaleString();
            if (unit) displayValue += ` ${unit}`;
            if (isScore) {
                const scoreClass = getScoreClass(value, scoreType);
                return `<span class="${scoreClass}">${displayValue}</span>`;
            }
            return displayValue;
        }

        function compareValues(valA, valB, higherIsBetter = true, isVolume = false) {
            const aIsNull = valA === null || valA === undefined || String(valA).trim() === '';
            const bIsNull = valB === null || valB === undefined || String(valB).trim() === '';

            if (aIsNull && bIsNull) return { classA: 'comparison-na', classB: 'comparison-na', valADisplay: '未測定', valBDisplay: '未測定' };
            if (aIsNull) return { classA: 'comparison-na', classB: 'comparison-better', valADisplay: '未測定', valBDisplay: valB };
            if (bIsNull) return { classA: 'comparison-better', classB: 'comparison-na', valADisplay: valA, valBDisplay: '未測定' };

            if (valA instanceof Date && valB instanceof Date) {
                 if (valA.getTime() === valB.getTime()) return { classA: 'comparison-equal', classB: 'comparison-equal', valADisplay: valA.toLocaleDateString(), valBDisplay: valB.toLocaleDateString() };
                 let aIsBetterDate = higherIsBetter ? valA > valB : valA < valB; 
                 return {
                    classA: aIsBetterDate ? 'comparison-better' : 'comparison-worse',
                    classB: aIsBetterDate ? 'comparison-worse' : 'comparison-better',
                    valADisplay: valA.toLocaleDateString(), valBDisplay: valB.toLocaleDateString()
                 }
            }
            
            if (isNaN(parseFloat(valA)) || isNaN(parseFloat(valB))) {
                if (String(valA).toLowerCase() === String(valB).toLowerCase()) return { classA: 'comparison-equal', classB: 'comparison-equal', valADisplay: valA, valBDisplay: valB };
                return { classA: '', classB: '', valADisplay: valA || 'N/A', valBDisplay: valB || 'N/A' };
            }


            const numA = parseFloat(valA);
            const numB = parseFloat(valB);

            if (numA === numB) return { classA: 'comparison-equal', classB: 'comparison-equal', valADisplay: valA, valBDisplay: valB };

            let aIsBetter;
            if (isVolume) { 
                aIsBetter = numA < numB;
            } else if (higherIsBetter) {
                aIsBetter = numA > numB;
            } else { 
                aIsBetter = numA < numB;
            }

            return {
                classA: aIsBetter ? 'comparison-better' : 'comparison-worse',
                classB: aIsBetter ? 'comparison-worse' : 'comparison-better',
                valADisplay: valA, valBDisplay: valB
            };
        }

        function openComparisonModal() {
            if (selectedCpuIds.length !== 2) {
                showNotification('比較するにはデバイスを2つ選択してください。', 'error');
                return;
            }

            const cpu1 = cpuData.find(c => c.id === selectedCpuIds[0]);
            const cpu2 = cpuData.find(c => c.id === selectedCpuIds[1]);

            if (!cpu1 || !cpu2) {
                showNotification('選択されたデバイスの読み込みに失敗しました。', 'error');
                return;
            }
            
            document.getElementById('comparisonTitle').textContent = `${cpu1.name} vs ${cpu2.name}`;
            const contentDiv = document.getElementById('comparisonContent');
            
            let tableHtml = `<table class="comparison-table">
                <thead>
                    <tr>
                        <th>特性</th>
                        <th>${cpu1.name} ${cpu1.isFavorite ? '<i class="fas fa-star" style="color:#ffc777;font-size:0.8em;"></i>' : ''}</th>
                        <th>${cpu2.name} ${cpu2.isFavorite ? '<i class="fas fa-star" style="color:#ffc777;font-size:0.8em;"></i>' : ''}</th>
                    </tr>
                </thead>
                <tbody>`;

            const fieldsToCompare = [
                { label: '製作者', keyA: cpu1.creator, keyB: cpu2.creator, compareFn: (a,b) => compareValues(a,b,false,false)}, 
            ];

            for (const key in SCORE_DEFINITIONS) {
                fieldsToCompare.push({
                    label: key.toUpperCase(),
                    keyA: cpu1.scores[key],
                    keyB: cpu2.scores[key],
                    unit: 't',
                    higherIsBetter: scoreSettings[key].highIsBetter,
                    isScore: true,
                    scoreType: key
                });
            }

            fieldsToCompare.push(
                { label: `マルチ最大 (${getSpeedUnit('multi')})`, keyA: cpu1.speeds.multi, keyB: cpu2.speeds.multi, unit: '', higherIsBetter: true },
                { label: `シングル最大 (${getSpeedUnit('single')})`, keyA: cpu1.speeds.single, keyB: cpu2.speeds.single, unit: '', higherIsBetter: true },
                { label: `シングル条件分岐 (${getSpeedUnit('branch')})`, keyA: cpu1.speeds.branch, keyB: cpu2.speeds.branch, unit: '', higherIsBetter: true },
                { label: 'コア', keyA: cpu1.cores, keyB: cpu2.cores, unit: '', higherIsBetter: true },
                { label: 'スレッド', keyA: cpu1.threads, keyB: cpu2.threads, unit: '', higherIsBetter: true },
                { label: 'データ幅', keyA: cpu1.bit, keyB: cpu2.bit, unit: '-bit', higherIsBetter: true },
                { label: '体積', keyA: cpu1.volume.x * cpu1.volume.y * cpu1.volume.z, keyB: cpu2.volume.x * cpu2.volume.y * cpu2.volume.z, unit: '', higherIsBetter: false, isVolume: true }, 
                { label: '完成日', keyA: new Date(cpu1.completionDate), keyB: new Date(cpu2.completionDate), compareFn: (a,b) => compareValues(a,b,true,false)}, 
                { label: 'マイクロアーキテクチャ', keyA: cpu1.microarchitecture, keyB: cpu2.microarchitecture, compareFn: (a,b) => compareValues(a,b,false,false)},
                { label: 'Edition', keyA: cpu1.minecraftEdition, keyB: cpu2.minecraftEdition, compareFn: (a,b) => compareValues(a,b,false,false)},
            );
            
            fieldsToCompare.forEach(field => {
                let comparisonResult;
                if(field.compareFn){
                     comparisonResult = field.compareFn(field.keyA, field.keyB);
                } else {
                     comparisonResult = compareValues(field.keyA, field.keyB, field.higherIsBetter, field.isVolume);
                }

                const valADisplay = field.isScore ? formatValueForComparison(comparisonResult.valADisplay, field.unit, true, field.scoreType) : formatValueForComparison(comparisonResult.valADisplay, field.unit);
                const valBDisplay = field.isScore ? formatValueForComparison(comparisonResult.valBDisplay, field.unit, true, field.scoreType) : formatValueForComparison(comparisonResult.valBDisplay, field.unit);


                tableHtml += `<tr>
                                <td>${field.label}</td>
                                <td class="cpu-value-cell ${comparisonResult.classA}">${valADisplay}</td>
                                <td class="cpu-value-cell ${comparisonResult.classB}">${valBDisplay}</td>
                              </tr>`;
            });

            const tagsA = cpu1.tags && cpu1.tags.length > 0 ? cpu1.tags.map(tag => `<span class="tag-badge ${getTagClass(tag)}">${tag}</span>`).join(' ') : 'タグなし';
            const tagsB = cpu2.tags && cpu2.tags.length > 0 ? cpu2.tags.map(tag => `<span class="tag-badge ${getTagClass(tag)}">${tag}</span>`).join(' ') : 'タグなし';
            tableHtml += `<tr>
                            <td>タグ</td>
                            <td class="tags-cell">${tagsA}</td>
                            <td class="tags-cell">${tagsB}</td>
                          </tr>`;

            const descA = cpu1.description ? cpu1.description.replace(/\n/g, '<br>') : "記載なし";
            const descB = cpu2.description ? cpu2.description.replace(/\n/g, '<br>') : "記載なし";
            tableHtml += `<tr>
                            <td>説明</td>
                            <td>${descA}</td>
                            <td>${descB}</td>
                          </tr>`;

            tableHtml += `</tbody></table>`;
            
            tableHtml += `<div id="comparisonChartContainer">
                            <canvas id="comparisonChartCanvas"></canvas>
                          </div>`;

            contentDiv.innerHTML = tableHtml;
            
            renderComparisonChart(cpu1, cpu2);

            openModal('comparisonModal');
        }

        function renderComparisonChart(cpu1, cpu2) {
            if (comparisonChart) {
                comparisonChart.destroy();
                comparisonChart = null;
            }
            const chartContainer = document.getElementById('comparisonChartContainer');
            const ctx = document.getElementById('comparisonChartCanvas').getContext('2d');
            const isDark = document.body.classList.contains('dark-theme');
            
            const labels = [];
            const originalData1 = [];
            const originalData2 = [];
            const dataSettings = [];

            for (const key in CHART_DEFINITIONS) {
                if (chartVisibility[key]) {
                    labels.push(CHART_DEFINITIONS[key].label);
                    let val1, val2, setting;
                    if (SCORE_DEFINITIONS[key]) {
                        val1 = cpu1.scores[key];
                        val2 = cpu2.scores[key];
                        setting = scoreSettings[key];
                    } else {
                        switch (key) {
                            case 'volume':
                                val1 = cpu1.volume.x * cpu1.volume.y * cpu1.volume.z;
                                val2 = cpu2.volume.x * cpu2.volume.y * cpu2.volume.z;
                                setting = { highIsBetter: false }; // Volume is always low is better
                                break;
                            default:
                                val1 = getScatterValue(cpu1, key);
                                val2 = getScatterValue(cpu2, key);
                                setting = { highIsBetter: true };
                                break;
                        }
                    }
                    originalData1.push(val1 || 0);
                    originalData2.push(val2 || 0);
                    dataSettings.push(setting);
                }
            }

            if (labels.length < 3) {
                chartContainer.innerHTML = `<p style="text-align:center; padding: 40px 20px; font-size: 1.1rem;"><i class="fas fa-info-circle"></i> グラフを表示するには、設定で3つ以上の項目を選択してください。</p>`;
                return;
            }

            const normalizedData1 = [];
            const normalizedData2 = [];

            for (let i = 0; i < labels.length; i++) {
                const val1 = originalData1[i];
                const val2 = originalData2[i];
                const setting = dataSettings[i];

                if (setting && !setting.highIsBetter) { // Low is better
                    const minVal = Math.min(val1, val2);
                    if (minVal > 0) {
                        normalizedData1.push(val1 > 0 ? (minVal / val1) * 100 : 0);
                        normalizedData2.push(val2 > 0 ? (minVal / val2) * 100 : 0);
                    } else { // Handle case where one or both values are 0
                        normalizedData1.push(val1 === 0 ? 100 : 0);
                        normalizedData2.push(val2 === 0 ? 100 : 0);
                    }
                } else { // High is better
                    const maxVal = Math.max(val1, val2);
                    if (maxVal > 0) {
                        normalizedData1.push((val1 / maxVal) * 100);
                        normalizedData2.push((val2 / maxVal) * 100);
                    } else {
                        normalizedData1.push(0);
                        normalizedData2.push(0);
                    }
                }
            }

            comparisonChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: cpu1.name,
                            data: normalizedData1,
                            originalData: originalData1,
                            backgroundColor: isDark ? 'rgba(122, 162, 247, 0.2)' : 'rgba(102, 126, 234, 0.2)',
                            borderColor: isDark ? '#7aa2f7' : 'rgba(102, 126, 234, 1)',
                            pointBackgroundColor: isDark ? '#7aa2f7' : 'rgba(102, 126, 234, 1)',
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: isDark ? '#7aa2f7' : 'rgba(102, 126, 234, 1)',
                            borderWidth: 2
                        },
                        {
                            label: cpu2.name,
                            data: normalizedData2,
                            originalData: originalData2,
                            backgroundColor: isDark ? 'rgba(187, 154, 247, 0.2)' : 'rgba(255, 107, 107, 0.2)',
                            borderColor: isDark ? '#bb9af7' : 'rgba(255, 107, 107, 1)',
                            pointBackgroundColor: isDark ? '#bb9af7' : 'rgba(255, 107, 107, 1)',
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: isDark ? '#bb9af7' : 'rgba(255, 107, 107, 1)',
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            angleLines: { display: true, color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' },
                            grid: { color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' },
                            pointLabels: { font: { size: 13, weight: '500' }, color: isDark ? '#c0caf5' : '#333' },
                            ticks: {
                                display: true,
                                backdropColor: 'transparent',
                                color: isDark ? '#a9b1d6' : '#666',
                                stepSize: 20,
                                callback: value => value + '%'
                            },
                            suggestedMin: 0,
                            suggestedMax: 100
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '性能バランス比較 (良い方を100%として正規化)',
                            font: { size: 16 },
                            padding: { bottom: 20 },
                            color: isDark ? '#c0caf5' : '#333'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const dataset = context.dataset;
                                    const datasetLabel = dataset.label || '';
                                    const originalValue = dataset.originalData[context.dataIndex];
                                    return `${datasetLabel}: ${originalValue.toLocaleString()}`;
                                }
                            }
                        },
                        legend: { position: 'top', labels: { color: isDark ? '#c0caf5' : '#333' } }
                    }
                }
            });
        }

        function exportDataAsJSON() {
            if (cpuData.length === 0) {
                showNotification('エクスポートするデータがありません。', 'info');
                return;
            }
            const jsonString = JSON.stringify(cpuData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cpu-data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification('<i class="fas fa-check-circle"></i> データをJSONファイルにエクスポートしました。', 'success');
        }

        function handleImportJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (!Array.isArray(importedData)) {
                        throw new Error('JSONが配列形式ではありません。');
                    }
                    if (importedData.length > 0 && (!importedData[0].id || !importedData[0].name)) {
                         throw new Error('JSONのデータ形式が正しくないようです。');
                    }

                    if (confirm('現在のデータをインポートしたデータで上書きしますか？この操作は元に戻せません。')) {
                        cpuData = importedData;
                        saveDataToLocalStorage();
                        renderCPUTable();
                        showNotification('<i class="fas fa-check-circle"></i> データのインポートが完了しました。', 'success');
                    }
                } catch (error) {
                    showNotification(`<i class="fas fa-exclamation-triangle"></i> インポートに失敗しました: ${error.message}`, 'error', 5000);
                } finally {
                    event.target.value = '';
                }
            };
            reader.onerror = function() {
                showNotification('<i class="fas fa-exclamation-triangle"></i> ファイルの読み込みに失敗しました。', 'error');
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        function openSettingsTab(evt, tabName) {
            const tabcontent = document.getElementsByClassName("settings-tab-content");
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            const tablinks = document.getElementsByClassName("tab-link");
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }

        function renderSettingsModal() {
            // Column Settings
            const columnList = document.getElementById('columnSettingsList');
            columnList.innerHTML = '';
            for (const key in COLUMN_DEFINITIONS) {
                const column = COLUMN_DEFINITIONS[key];
                const listItem = document.createElement('li');
                const label = document.createElement('label');
                label.htmlFor = `col-toggle-${key}`;
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `col-toggle-${key}`;
                checkbox.dataset.columnKey = key;
                checkbox.checked = columnVisibility[key];
                const span = document.createElement('span');
                span.textContent = column.label;
                label.appendChild(checkbox);
                label.appendChild(span);
                listItem.appendChild(label);
                columnList.appendChild(listItem);
            }

            // Chart Settings
            const chartList = document.getElementById('chartSettingsList');
            chartList.innerHTML = '';
            for (const key in CHART_DEFINITIONS) {
                const chartItem = CHART_DEFINITIONS[key];
                const listItem = document.createElement('li');
                const label = document.createElement('label');
                label.htmlFor = `chart-toggle-${key}`;
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `chart-toggle-${key}`;
                checkbox.dataset.chartKey = key;
                checkbox.checked = chartVisibility[key];
                const span = document.createElement('span');
                span.textContent = chartItem.label;
                label.appendChild(checkbox);
                label.appendChild(span);
                listItem.appendChild(label);
                chartList.appendChild(listItem);
            }

            // Scatter Plot Settings
            const xSelect = document.getElementById('scatterXAxis');
            const ySelect = document.getElementById('scatterYAxis');
            const rSelect = document.getElementById('scatterBubbleSize');
            [xSelect, ySelect, rSelect].forEach(select => select.innerHTML = '');

            const noneOption = document.createElement('option');
            noneOption.value = 'none';
            noneOption.textContent = 'なし';
            rSelect.appendChild(noneOption);

            for (const key in SCATTER_PLOT_AXIS_DEFINITIONS) {
                const item = SCATTER_PLOT_AXIS_DEFINITIONS[key];
                const option = document.createElement('option');
                option.value = key;
                option.textContent = item.label;
                xSelect.appendChild(option.cloneNode(true));
                ySelect.appendChild(option.cloneNode(true));
                rSelect.appendChild(option.cloneNode(true));
            }

            // Theme Settings
            const themeContainer = document.getElementById('themeSelectionContainer');
            themeContainer.innerHTML = `
                <label id="lightThemeLabel">
                    <input type="radio" name="theme" value="light">
                    <i class="fas fa-sun"></i>
                    <span>ライト</span>
                </label>
                <label id="darkThemeLabel">
                    <input type="radio" name="theme" value="dark">
                    <i class="fas fa-moon"></i>
                    <span>ダーク</span>
                </label>
            `;
            themeContainer.querySelectorAll('input[name="theme"]').forEach(radio => {
                radio.addEventListener('change', (event) => {
                    setTheme(event.target.value, true); 
                    updateThemeSelectionUI();
                });
            });
        }

        function openSettingsModal() {
            document.querySelectorAll('#columnSettingsList input[type="checkbox"]').forEach(cb => {
                cb.checked = columnVisibility[cb.dataset.columnKey];
            });
            document.querySelectorAll('#chartSettingsList input[type="checkbox"]').forEach(cb => {
                cb.checked = chartVisibility[cb.dataset.chartKey];
            });
            document.getElementById('scatterXAxis').value = scatterPlotSettings.x;
            document.getElementById('scatterYAxis').value = scatterPlotSettings.y;
            document.getElementById('scatterBubbleSize').value = scatterPlotSettings.r;
            
            renderTagManagementTab();
            renderScoreSettingsTab();
            updateThemeSelectionUI();

            openModal('settingsModal');
        }

        function saveAllSettingsAndCloseModal() {
            // Save column visibility
            document.querySelectorAll('#columnSettingsList input[type="checkbox"]').forEach(cb => {
                columnVisibility[cb.dataset.columnKey] = cb.checked;
            });
            saveColumnVisibilityToLocalStorage();
            applyColumnVisibility();

            // Save chart visibility
            document.querySelectorAll('#chartSettingsList input[type="checkbox"]').forEach(cb => {
                chartVisibility[cb.dataset.chartKey] = cb.checked;
            });
            saveChartVisibilityToLocalStorage();
            
            // Save score settings
            for (const key in scoreSettings) {
                const highThresholdInput = document.getElementById(`${key}-high-threshold`);
                const mediumThresholdInput = document.getElementById(`${key}-medium-threshold`);
                if (highThresholdInput && mediumThresholdInput) {
                    scoreSettings[key].highThreshold = parseInt(highThresholdInput.value, 10);
                    scoreSettings[key].mediumThreshold = parseInt(mediumThresholdInput.value, 10);
                }
            }
            saveScoreSettingsToLocalStorage();

            // Save scatter plot settings
            scatterPlotSettings.x = document.getElementById('scatterXAxis').value;
            scatterPlotSettings.y = document.getElementById('scatterYAxis').value;
            scatterPlotSettings.r = document.getElementById('scatterBubbleSize').value;
            saveScatterPlotSettingsToLocalStorage();
            
            renderCPUTable(); // Re-render table to apply new score settings
            closeModal('settingsModal');
            showNotification('<i class="fas fa-check-circle"></i> 設定を保存しました。', 'success');
        }

        // --- NEW: Score Settings Tab Functions ---
        function renderScoreSettingsTab() {
            const container = document.getElementById('scoreSettingsContainer');
            container.innerHTML = '';

            for (const key in scoreSettings) {
                const setting = scoreSettings[key];
                const item = document.createElement('div');
                item.className = 'score-setting-item';
                item.innerHTML = `
                    <h4>${key.toUpperCase()}</h4>
                    <div class="form-group">
                        <label>評価基準</label>
                        <button id="${key}-behavior-btn" class="behavior-toggle-btn" onclick="toggleScoreBehavior('${key}')"></button>
                    </div>
                    <div class="form-group">
                        <label id="${key}-high-label"></label>
                        <input type="number" id="${key}-high-threshold" value="${setting.highThreshold}">
                    </div>
                    <div class="form-group">
                        <label id="${key}-medium-label"></label>
                        <input type="number" id="${key}-medium-threshold" value="${setting.mediumThreshold}">
                    </div>
                `;
                container.appendChild(item);
                updateScoreBehaviorUI(key);
            }
        }

        function toggleScoreBehavior(key) {
            scoreSettings[key].highIsBetter = !scoreSettings[key].highIsBetter;
            updateScoreBehaviorUI(key);
        }

        function updateScoreBehaviorUI(key) {
            const setting = scoreSettings[key];
            const btn = document.getElementById(`${key}-behavior-btn`);
            const highLabel = document.getElementById(`${key}-high-label`);
            const mediumLabel = document.getElementById(`${key}-medium-label`);

            if (setting.highIsBetter) {
                btn.textContent = '値が高いほど良い';
                btn.className = 'behavior-toggle-btn high-is-better';
                highLabel.textContent = '高スコアの閾値 (この値以上)';
                mediumLabel.textContent = '中スコアの閾値 (この値以上)';
            } else {
                btn.textContent = '値が低いほど良い';
                btn.className = 'behavior-toggle-btn low-is-better';
                highLabel.textContent = '高スコアの閾値 (この値以下)';
                mediumLabel.textContent = '中スコアの閾値 (この値以下)';
            }
        }
        // --- END: Score Settings Tab Functions ---

        // --- Tag Management Functions ---
        function renderTagManagementTab() {
            const list = document.getElementById('tagManagementList');
            list.innerHTML = '';
            AVAILABLE_TAGS.forEach(tag => {
                const listItem = document.createElement('li');
                listItem.className = 'tag-management-item';
                listItem.dataset.tagName = tag;
                listItem.innerHTML = `
                    <span class="tag-item-name">${tag}</span>
                    <div class="tag-item-actions">
                        <button class="edit-tag-btn" title="編集" onclick="showEditTagInput('${tag}', this)"><i class="fas fa-pen"></i></button>
                        <button class="delete-tag-btn" title="削除" onclick="deleteTag('${tag}')"><i class="fas fa-trash"></i></button>
                    </div>
                `;
                list.appendChild(listItem);
            });
        }

        function addNewTag() {
            const input = document.getElementById('newTagName');
            const newTagName = input.value.trim();

            if (!newTagName) {
                showNotification('タグ名を入力してください。', 'error');
                return;
            }
            if (AVAILABLE_TAGS.some(tag => tag.toLowerCase() === newTagName.toLowerCase())) {
                showNotification(`タグ「${newTagName}」は既に存在します。`, 'error');
                return;
            }

            AVAILABLE_TAGS.push(newTagName);
            saveTagsToLocalStorage();
            updateAllTagUIs();
            input.value = '';
            showNotification(`タグ「${newTagName}」を追加しました。`, 'success');
        }

        function showEditTagInput(tagName, buttonElement) {
            const listItem = buttonElement.closest('.tag-management-item');
            const originalContent = listItem.innerHTML;

            listItem.innerHTML = `
                <form class="tag-edit-form" onsubmit="event.preventDefault(); saveTagEdit('${tagName}', this.querySelector('.tag-edit-input'));">
                    <input type="text" class="tag-edit-input" value="${tagName}">
                    <div class="tag-item-actions">
                        <button type="submit" class="save-tag-btn" title="保存"><i class="fas fa-check"></i></button>
                        <button type="button" class="cancel-tag-btn" title="キャンセル" onclick="cancelTagEdit('${tagName}', \`${encodeURIComponent(originalContent)}\`)"><i class="fas fa-times"></i></button>
                    </div>
                </form>
            `;
            listItem.querySelector('.tag-edit-input').focus();
        }
        
        function saveTagEdit(oldTagName, inputElement) {
            const newTagName = inputElement.value.trim();

            if (!newTagName) {
                showNotification('タグ名は空にできません。', 'error');
                return;
            }
            if (newTagName.toLowerCase() !== oldTagName.toLowerCase() && AVAILABLE_TAGS.some(tag => tag.toLowerCase() === newTagName.toLowerCase())) {
                showNotification(`タグ「${newTagName}」は既に存在します。`, 'error');
                return;
            }

            const tagIndex = AVAILABLE_TAGS.findIndex(t => t === oldTagName);
            if (tagIndex > -1) {
                AVAILABLE_TAGS[tagIndex] = newTagName;
            }

            cpuData.forEach(cpu => {
                const cpuTagIndex = cpu.tags.indexOf(oldTagName);
                if (cpuTagIndex > -1) {
                    cpu.tags[cpuTagIndex] = newTagName;
                }
            });

            saveTagsToLocalStorage();
            saveDataToLocalStorage();
            updateAllTagUIs();
            showNotification(`タグ「${oldTagName}」を「${newTagName}」に更新しました。`, 'success');
        }

        function cancelTagEdit(tagName, encodedOriginalContent) {
            const listItem = document.querySelector(`.tag-management-item[data-tag-name="${tagName}"]`);
            if (listItem) {
                listItem.innerHTML = decodeURIComponent(encodedOriginalContent);
            }
        }

        function deleteTag(tagName) {
            if (confirm(`本当にタグ「${tagName}」を削除しますか？\nこのタグはすべてのデバイスからも削除されます。`)) {
                AVAILABLE_TAGS = AVAILABLE_TAGS.filter(t => t !== tagName);

                cpuData.forEach(cpu => {
                    cpu.tags = cpu.tags.filter(t => t !== tagName);
                });

                saveTagsToLocalStorage();
                saveDataToLocalStorage();
                updateAllTagUIs();
                showNotification(`タグ「${tagName}」を削除しました。`, 'info');
            }
        }

        function updateAllTagUIs() {
            if (document.getElementById('settingsModal').classList.contains('visible')) {
                renderTagManagementTab();
            }
            renderTagFilters();
            renderCPUTable();
            if (document.getElementById('cpuFormModal').classList.contains('visible')) {
                const editingIdStr = document.getElementById('editingCpuId').value;
                const editingId = editingIdStr ? parseInt(editingIdStr) : null;
                let currentTags = [];
                if (editingId) {
                    const cpu = cpuData.find(c => c.id === editingId);
                    if (cpu) currentTags = cpu.tags;
                }
                renderTagSelectionCheckboxes('tagSelectionCheckboxes', currentTags);
            }
        }


        // --- Scatter Plot Functions ---
        function openScatterPlotModal() {
            openModal('scatterPlotModal');
            setTimeout(renderScatterPlot, 50);
        }

        function getScatterValue(cpu, key) {
            if (!key || key === 'none') return null;
            if (key === 'volume') {
                return cpu.volume.x * cpu.volume.y * cpu.volume.z;
            } else if (SCORE_DEFINITIONS[key]) {
                return cpu.scores[key];
            } else if (key === 'multiSpeed') {
                return cpu.speeds.multi;
            } else if (key === 'singleSpeed') {
                return cpu.speeds.single;
            } else if (key === 'branchSpeed') {
                return cpu.speeds.branch;
            } else {
                return cpu[key];
            }
        }

        function renderScatterPlot() {
            if (scatterPlotChart) {
                scatterPlotChart.destroy();
                scatterPlotChart = null;
            }

            const ctx = document.getElementById('scatterPlotCanvas').getContext('2d');
            const isDark = document.body.classList.contains('dark-theme');

            const { x: xKey, y: yKey, r: rKey } = scatterPlotSettings;
            
            const dataPoints = cpuData.map(cpu => {
                const xVal = getScatterValue(cpu, xKey);
                const yVal = getScatterValue(cpu, yKey);
                
                if (xVal === null || xVal === undefined || yVal === null || yVal === undefined) {
                    return null;
                }

                return {
                    x: xVal,
                    y: yVal,
                    rVal: getScatterValue(cpu, rKey),
                    cpu: cpu
                };
            }).filter(p => p !== null);

            const rValues = dataPoints.map(p => p.rVal).filter(v => v !== null && v !== undefined);
            const maxR = rValues.length > 0 ? Math.max(...rValues) : 0;

            dataPoints.forEach(p => {
                if (p.rVal !== null && p.rVal !== undefined && maxR > 0) {
                    p.r = 5 + (p.rVal / maxR) * 20;
                } else {
                    p.r = 5;
                }
            });

            const xLabel = SCATTER_PLOT_AXIS_DEFINITIONS[xKey]?.label || 'X軸';
            const yLabel = SCATTER_PLOT_AXIS_DEFINITIONS[yKey]?.label || 'Y軸';
            const rLabel = SCATTER_PLOT_AXIS_DEFINITIONS[rKey]?.label || '';

            scatterPlotChart = new Chart(ctx, {
                type: 'bubble',
                data: {
                    datasets: [{
                        label: 'デバイス',
                        data: dataPoints,
                        backgroundColor: isDark ? 'rgba(115, 218, 202, 0.6)' : 'rgba(38, 222, 129, 0.6)',
                        borderColor: isDark ? '#73daca' : 'rgba(38, 222, 129, 1)',
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const firstElement = elements[0];
                            const cpu = dataPoints[firstElement.index].cpu;
                            closeModal('scatterPlotModal');
                            setTimeout(() => showCPUDetails(cpu.id), 300);
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: xLabel, font: { size: 14 }, color: isDark ? '#c0caf5' : '#333' },
                            ticks: { color: isDark ? '#a9b1d6' : '#666' },
                            grid: { color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' }
                        },
                        y: {
                            title: { display: true, text: yLabel, font: { size: 14 }, color: isDark ? '#c0caf5' : '#333' },
                            ticks: { color: isDark ? '#a9b1d6' : '#666' },
                            grid: { color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: '性能散布図',
                            font: { size: 16 },
                            padding: { bottom: 20 },
                            color: isDark ? '#c0caf5' : '#333'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const data = context.raw;
                                    const cpu = data.cpu;
                                    let lines = [`${cpu.name} (${cpu.creator})`];
                                    lines.push('--------------------');
                                    lines.push(`${xLabel}: ${data.x.toLocaleString()}`);
                                    lines.push(`${yLabel}: ${data.y.toLocaleString()}`);
                                    if (rKey !== 'none' && data.rVal !== null) {
                                        lines.push(`${rLabel}: ${data.rVal.toLocaleString()}`);
                                    }
                                    return lines;
                                }
                            }
                        }
                    }
                }
            });
        }

        // --- Statistics Modal Functions ---
        function openStatisticsModal() {
            const stats = calculateStatistics();
            renderStatisticsModalContent(stats);
            openModal('statisticsModal');
            // モーダルが表示された後にチャートを描画
            setTimeout(() => {
                renderStatisticsCharts(stats);
            }, 50);
        }

        function formatStatValue(value, precision = 2) {
            if (typeof value === 'number') {
                if (value % 1 === 0) {
                    return value.toLocaleString();
                }
                return value.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: precision });
            }
            return value; // 'N/A' などをそのまま返す
        }

        function calculateStatistics() {
            const stats = {
                totalDevices: cpuData.length,
                uniqueCreators: new Set(cpuData.map(c => c.creator)).size,
                totalTags: AVAILABLE_TAGS.length,
                avgMultiSpeed: 'N/A',
                avgVolume: 'N/A',
                topSpeedDevice: { name: 'N/A', value: 0 },
                mostCompactDevice: { name: 'N/A', value: Infinity },
                editionDistribution: {},
                tagUsage: {}
            };

            if (cpuData.length === 0) return stats;

            let totalMultiSpeed = 0;
            let multiSpeedCount = 0;
            let totalVolume = 0;
            let volumeCount = 0;

            cpuData.forEach(cpu => {
                // Multi Speed
                if (cpu.speeds.multi !== null && cpu.speeds.multi !== undefined) {
                    totalMultiSpeed += cpu.speeds.multi;
                    multiSpeedCount++;
                    if (cpu.speeds.multi > stats.topSpeedDevice.value) {
                        stats.topSpeedDevice = { name: cpu.name, value: cpu.speeds.multi };
                    }
                }

                // Volume
                const volume = cpu.volume.x * cpu.volume.y * cpu.volume.z;
                if (volume > 0) {
                    totalVolume += volume;
                    volumeCount++;
                    if (volume < stats.mostCompactDevice.value) {
                        stats.mostCompactDevice = { name: cpu.name, value: volume };
                    }
                }
                
                // Edition
                const edition = cpu.minecraftEdition || '不明';
                stats.editionDistribution[edition] = (stats.editionDistribution[edition] || 0) + 1;
                
                // Tags
                (cpu.tags || []).forEach(tag => {
                    stats.tagUsage[tag] = (stats.tagUsage[tag] || 0) + 1;
                });
            });

            if (multiSpeedCount > 0) {
                stats.avgMultiSpeed = totalMultiSpeed / multiSpeedCount;
            }
            if (volumeCount > 0) {
                stats.avgVolume = totalVolume / volumeCount;
            }
            
            if (stats.topSpeedDevice.name === 'N/A') stats.topSpeedDevice.value = 'N/A';
            if (stats.mostCompactDevice.name === 'N/A') stats.mostCompactDevice.value = 'N/A';

            stats.sortedTagUsage = Object.entries(stats.tagUsage).sort(([, a], [, b]) => b - a).slice(0, 10);

            return stats;
        }

        function renderStatisticsModalContent(stats) {
            const contentDiv = document.getElementById('statisticsContent');
            if (stats.totalDevices === 0) {
                contentDiv.innerHTML = `<p style="text-align:center; padding: 40px 20px; font-size: 1.1rem;"><i class="fas fa-info-circle"></i> 統計情報を表示するためのデータがありません。</p>`;
                return;
            }

            const topSpeedDeviceText = stats.topSpeedDevice.name !== 'N/A'
                ? `${stats.topSpeedDevice.name} (${formatStatValue(stats.topSpeedDevice.value, 0)} OPS)`
                : 'N/A';

            const mostCompactDeviceText = stats.mostCompactDevice.name !== 'N/A'
                ? `${stats.mostCompactDevice.name} (${formatStatValue(stats.mostCompactDevice.value, 0)} b³)`
                : 'N/A';

            contentDiv.innerHTML = `
                <div class="stats-main-container">
                    <div class="stats-info-column">
                        <div class="stats-card">
                            <h3><i class="fas fa-database"></i> 基本統計</h3>
                            <div class="stats-item"><span class="stats-label">登録デバイス数:</span><span class="stats-value">${stats.totalDevices}</span></div>
                            <div class="stats-item"><span class="stats-label">ユニーク製作者数:</span><span class="stats-value">${stats.uniqueCreators}</span></div>
                            <div class="stats-item"><span class="stats-label">登録タグ種類数:</span><span class="stats-value">${stats.totalTags}</span></div>
                            <hr>
                            <div class="stats-item"><span class="stats-label">平均マルチ最大速度:</span><span class="stats-value">${formatStatValue(stats.avgMultiSpeed, 0)} OPS</span></div>
                            <div class="stats-item"><span class="stats-label">平均体積:</span><span class="stats-value">${formatStatValue(stats.avgVolume, 0)} ブロック³</span></div>
                            <hr>
                            <div class="stats-item"><span class="stats-label">最高速度デバイス:</span><span class="stats-value">${topSpeedDeviceText}</span></div>
                            <div class="stats-item"><span class="stats-label">最小体積デバイス:</span><span class="stats-value">${mostCompactDeviceText}</span></div>
                        </div>
                    </div>
                    <div class="stats-charts-column">
                        <div class="stats-chart-wrapper">
                            <canvas id="editionChartCanvas"></canvas>
                        </div>
                        <div class="stats-chart-wrapper">
                            <canvas id="tagChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderStatisticsCharts(stats) {
            const isDark = document.body.classList.contains('dark-theme');
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            const textColor = isDark ? '#c0caf5' : '#333';
            const chartColors = isDark 
                ? ['#f7768e', '#9ece6a', '#7aa2f7', '#e0af68', '#bb9af7', '#ff9e64', '#73daca', '#c0caf5']
                : ['#ff6b6b', '#4ecdc4', '#feca57', '#54a0ff', '#9b59b6', '#1dd1a1', '#ff9f43', '#2e86de'];

            // Edition Distribution Chart
            const editionCtx = document.getElementById('editionChartCanvas')?.getContext('2d');
            if (editionCtx) {
                const editionLabels = Object.keys(stats.editionDistribution);
                const editionData = Object.values(stats.editionDistribution);
                statisticsCharts.edition = new Chart(editionCtx, {
                    type: 'doughnut',
                    data: {
                        labels: editionLabels,
                        datasets: [{
                            data: editionData,
                            backgroundColor: chartColors,
                            borderColor: isDark ? '#24283b' : '#fff',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'top', labels: { color: textColor } },
                            title: { display: true, text: 'Minecraft Edition 分布', color: textColor, font: { size: 16 } }
                        }
                    }
                });
            }

            // Tag Usage Chart
            const tagCtx = document.getElementById('tagChartCanvas')?.getContext('2d');
            if (tagCtx && stats.sortedTagUsage.length > 0) {
                const tagLabels = stats.sortedTagUsage.map(item => item[0]);
                const tagData = stats.sortedTagUsage.map(item => item[1]);
                statisticsCharts.tag = new Chart(tagCtx, {
                    type: 'bar',
                    data: {
                        labels: tagLabels,
                        datasets: [{
                            label: '使用回数',
                            data: tagData,
                            backgroundColor: chartColors.slice(0, tagLabels.length),
                            borderColor: chartColors.slice(0, tagLabels.length),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true, maintainAspectRatio: false,
                        scales: {
                            x: { ticks: { color: textColor, precision: 0 }, grid: { color: gridColor } },
                            y: { ticks: { color: textColor }, grid: { color: gridColor } }
                        },
                        plugins: {
                            legend: { display: false },
                            title: { display: true, text: 'タグ使用率 Top 10', color: textColor, font: { size: 16 } }
                        }
                    }
                });
            } else if (tagCtx) {
                 tagCtx.font = `16px ${getComputedStyle(document.body).fontFamily}`;
                 tagCtx.fillStyle = textColor;
                 tagCtx.textAlign = 'center';
                 tagCtx.fillText('タグデータがありません', tagCtx.canvas.width / 2, tagCtx.canvas.height / 2);
            }
        }

        // --- NEW: Description Modal Functions ---
        function openDescriptionModal() {
            renderDescriptionModalContent();
            openModal('descriptionModal');
        }

        function renderDescriptionModalContent() {
            const descriptions = {
                "RCBSP": { title: "Single Process Increment", text: "1スレッドのみ使用し、レジスタの値を0から8までインクリメントするのにかかった時間を測定します。単純な命令処理速度とパイプライン性能を評価します。" },
                "RCBFA": { title: "Single Process Factorial", text: "1スレッドのみ使用し、5の階乗（5!）を計算する処理が完了するまでの時間を測定します。ループ・分岐・乗算の組み合わせに対する処理性能を評価します。" },
                "RCBMP": { title: "Multi Process Increment", text: "すべてのスレッドを用いて、同時にそれぞれインクリメント処理を行い、合計16回分のインクリメント処理が完了するまでの時間を測定します。スレッド間の独立性と並列処理能力を評価します。" },
                "RCBWM": { title: "Write to Memory", text: "レジスタの値をメモリに連続で書き込む処理の速度を測定します。メモリ書き込み帯域とアドレス計算性能を評価します。" },
                "RCBRM": { title: "Read from Memory", text: "メモリから別のメモリ位置へと連続的に読み込み・コピーする処理の速度を測定します。メモリアクセスおよび内部バス帯域の性能を評価します。" },
                "RCBML": { title: "Integer Multiply", text: "2つの整数値を掛け算する命令の処理速度を測定します。FPUなしの固定長整数演算による乗算性能を評価します。" },
                "RCBDV": { title: "Integer Divide", text: "2つの整数値を割り算する命令の処理速度を測定します。除算回路（または逐次的演算）の実行速度を評価します。" },
                "RCBSQ": { title: "Integer Square Root", text: "整数の平方根を求める命令またはアルゴリズムの実行速度を測定します。繰り返し演算や比較処理の性能が反映されます。" },
                "RCBSH": { title: "Barrel Shift", text: "指定回数だけビットを右方向へシフトする処理の速度を測定します。バレルシフタ回路の有無やシフト実行時間に関する性能を評価します。" }
            };
            const container = document.getElementById('descriptionContent');
            container.innerHTML = '';
            for (const key in descriptions) {
                const desc = descriptions[key];
                const section = document.createElement('div');
                section.className = 'detail-section';
                section.innerHTML = `
                    <h3><i class="fas fa-tachometer-alt"></i> ${key} : ${desc.title}</h3>
                    <p style="line-height: 1.7;">${desc.text}</p>
                `;
                container.appendChild(section);
            }
        }

    </script>
</body>
</html>